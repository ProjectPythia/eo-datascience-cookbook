{"version":"1","records":[{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook"},"type":"lvl1","url":"/#earth-observation-data-science-cookbook","position":2},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook"},"content":"\n\n\n\n\n\n\n\nThis Project Pythia Cookbook covers a range of Earth observation examples employing\nthe Pangeo philosophy. The examples represent the main research lines and BSc/MSc\ncourses at the Department of Geodesy and Geoinformation at the TU Wien (Austria).\nThe department has strong ties with the EODC (Earth Observation Data Centre For\nWater Resources Monitoring), which hosts e.g., analysis-ready Sentinel-1\n(imaging radar mission) data, and has the computational resources to process\nlarge data volumes.","type":"content","url":"/#earth-observation-data-science-cookbook","position":3},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl2":"Motivation"},"type":"lvl2","url":"/#motivation","position":4},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl2":"Motivation"},"content":"The motivation behind this book is to provide examples of Pangeo-based workflows\napplied to realistic examples in Earth observation data science. Creating an\neffective learning environment for Earth observation students is a challenging\ntask due to the rapidly growing volume of remotely sensed, climate, and other\nEarth observation data, along with the evolving demands from the tech industry.\nTodayâ€™s Earth observation students are increasingly becoming a blend of traditional\nEarth system scientists and â€œbig data scientistsâ€, with expertise spanning computer\narchitectures, programming paradigms, statistics, and machine learning for\npredictive modeling. As a result, it is essential to equip educators with the\nproper tools for instruction, including training materials, access to data, and\nthe necessary skills to support scalable and reproducible research.","type":"content","url":"/#motivation","position":5},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl2":"Authors"},"type":"lvl2","url":"/#authors","position":6},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl2":"Authors"},"content":"Wolfgang Wagner, \n\nMartin Schobben,\n\n\nNikolas Pikall, \n\nJoseph Wagner, \n\nDavide Festa,\n\n\nFelix David ReuÃŸ, \n\nLuka Jovic","type":"content","url":"/#authors","position":7},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Contributors","lvl2":"Authors"},"type":"lvl3","url":"/#contributors","position":8},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Contributors","lvl2":"Authors"},"content":"","type":"content","url":"/#contributors","position":9},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl2":"Structure"},"type":"lvl2","url":"/#structure","position":10},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl2":"Structure"},"content":"This book comprises examples of data science concerning Earth Observation (EO) data,\nincluding course material on remote sensing and data products produced by the TU\nWien. It also serves to showcase the data and services offered by the EODC, including\na \n\nSTAC catalogue and a\n\n\nDask Gateway for distributed data processing.","type":"content","url":"/#structure","position":11},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Courses","lvl2":"Structure"},"type":"lvl3","url":"/#courses","position":12},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Courses","lvl2":"Structure"},"content":"This section offers an overview of notebooks, which are used in courses from\nthe Department of Geodesy and Geoinformation at TU Wien.","type":"content","url":"/#courses","position":13},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Templates","lvl2":"Structure"},"type":"lvl3","url":"/#templates","position":14},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Templates","lvl2":"Structure"},"content":"This section provides a collection of general examples of earth observation\nrelated tasks and workflows, which are not directly related to a specific course\nor product.","type":"content","url":"/#templates","position":15},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Tutorials","lvl2":"Structure"},"type":"lvl3","url":"/#tutorials","position":16},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Tutorials","lvl2":"Structure"},"content":"In this section you will find a collection of lessons, which explain certain\nproducts or methods that have been developed at the Department of Geodesy and\nGeoinformation at TU Wien.","type":"content","url":"/#tutorials","position":17},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl2":"Running the Notebooks"},"type":"lvl2","url":"/#running-the-notebooks","position":18},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl2":"Running the Notebooks"},"content":"You can either run the notebook using \n\nBinder\nor on your local machine.","type":"content","url":"/#running-the-notebooks","position":19},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-binder","position":20},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Running on Binder","lvl2":"Running the Notebooks"},"content":"The simplest way to interact with a Jupyter Notebook is through\n\n\nBinder, which enables the execution of a\n\n\nJupyter Book in the cloud. The details of how this works are not\nimportant for now. All you need to know is how to launch a Pythia\nCookbooks chapter via Binder. Simply navigate your mouse to\nthe top right corner of the book chapter you are viewing and click\non the rocket ship icon, (see figure below), and be sure to select\nâ€œlaunch Binderâ€. After a moment you should be presented with a\nnotebook that you can interact with. I.e. youâ€™ll be able to execute\nand even change the example programs. Youâ€™ll see that the code cells\nhave no output at first, until you execute them by pressing\nShift+Enter. Complete details on how to interact with\na live Jupyter notebook are described in \n\nGetting Started with\nJupyter.","type":"content","url":"/#running-on-binder","position":21},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"type":"lvl3","url":"/#running-on-your-own-machine","position":22},{"hierarchy":{"lvl1":"Earth Observation Data Science Cookbook","lvl3":"Running on Your Own Machine","lvl2":"Running the Notebooks"},"content":"If you are interested in running this material locally on your computer, you will\nneed to follow this workflow:\n\nClone the https://github.com/ProjectPythia/eo-datascience-cookbook repository: git clone https://github.com/TUW-GEO/eo-datascience-cookbook\n\nMove into the eo-datascience-cookbook directorycd eo-datascience-cookbook\n\nCreate and activate your conda environment from the environment.yml fileconda env create -f environment.yml\nconda activate eo-datascience-cookbook-dev\n\nMove into the notebooks directory and start up Jupyterlabcd notebooks/\njupyter lab","type":"content","url":"/#running-on-your-own-machine","position":23},{"hierarchy":{"lvl1":"Microwave Remote Sensing"},"type":"lvl1","url":"/notebooks/courses/microwave-remote-sensing","position":0},{"hierarchy":{"lvl1":"Microwave Remote Sensing"},"content":"This course at the TU Wien teaches students to read, visualize and analyze\nSynthetic Aperture Radar (SAR) data. This will aid interpretation of SAR data\nbased upon a physical understanding of sensing principles and the interaction of\nmicrowaves with natural objects.\n\nConcepts\n\nImportance\n\nNotes\n\nIntro to xarray\n\nNecessary\n\n\n\nDask Arrays\n\nNecessary\n\n\n\nIntake\n\nHelpful\n\n\n\nMatplotlib\n\nHelpful\n\nPloting in Python\n\nDocumentation hvPlot\n\nHelpful\n\nInteractive plotting\n\nDocumentation odc-stac\n\nHelpful\n\nData access\n\nTime to learn: 90 min\n\nNote\n\nThese notebooks contain interactive elements. The full interactive elements can\nonly be viewed on Binder by clicking on the Binder badge or ğŸš€ button.","type":"content","url":"/notebooks/courses/microwave-remote-sensing","position":1},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"type":"lvl1","url":"/notebooks/how-to-cite","position":0},{"hierarchy":{"lvl1":"How to Cite This Cookbook"},"content":"The material in this Project Pythia Cookbook is licensed for free and open consumption and reuse. All code is served under \n\nApache 2.0, while all non-code content is licensed under \n\nCreative Commons BY 4.0 (CC BY 4.0). Effectively, this means you are free to share and adapt this material so long as you give appropriate credit to the Cookbook authors and the Project Pythia community.\n\nThe source code for the book is \n\nreleased on GitHub and archived on Zenodo. This DOI will always resolve to the latest release of the book source:\n\n","type":"content","url":"/notebooks/how-to-cite","position":1},{"hierarchy":{"lvl1":"References"},"type":"lvl1","url":"/notebooks/references","position":0},{"hierarchy":{"lvl1":"References"},"content":"","type":"content","url":"/notebooks/references","position":1},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery"},"type":"lvl1","url":"/notebooks/templates/classification","position":0},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery"},"content":"Finding forests with satellite imagery","type":"content","url":"/notebooks/templates/classification","position":1},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl2":"Data Acquisition"},"type":"lvl2","url":"/notebooks/templates/classification#data-acquisition","position":2},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl2":"Data Acquisition"},"content":"In this chapter, we will employ machine learning techniques to classify a scene using satellite imagery. Specifically, we will utilize scikit-learn to implement two distinct classifiers and subsequently compare their results. To begin, we need to import the following modules.\n\nfrom datetime import datetime, timedelta\n\nimport cmcrameri as cmc  # noqa: F401\nimport geopandas as gpd\nimport matplotlib.colors as colors\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport odc.stac\nimport pandas as pd\nimport pystac_client\nimport rioxarray  # noqa: F401\nimport xarray as xr\nfrom odc.geo.geobox import GeoBox\nfrom shapely.geometry import Polygon\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.model_selection import train_test_split\n\n# Scikit Learn\nfrom sklearn.naive_bayes import GaussianNB\n\nBefore we start, we need to load the data. We will use odc-stac to obtain data from Earth Search by Element 84. Here we define the area of interest and the time frame, aswell as the EPSG code and the resolution.","type":"content","url":"/notebooks/templates/classification#data-acquisition","position":3},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Searching in the Catalog","lvl2":"Data Acquisition"},"type":"lvl3","url":"/notebooks/templates/classification#searching-in-the-catalog","position":4},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Searching in the Catalog","lvl2":"Data Acquisition"},"content":"The module odc-stac provides access to free, open source satelite data. To retrieve the data, we must define  several parameters that specify the location and time period for the satellite data. Additionally, we must specify the data collection we wish to access, as multiple collections are available. In this example, we will use multispectral imagery from the Sentinel-2 satellite.\n\ndx = 0.0006  # 60m resolution\nepsg = 4326\n\n# Set Spatial extent\nlatmin, latmax = 47.86, 48.407\nlonmin, lonmax = 16.32, 16.9\nbounds = (lonmin, latmin, lonmax, latmax)\n\n\n# Set Temporal extent\nstart_date = datetime(year=2024, month=5, day=1)\nend_date = start_date + timedelta(days=10)\n\ntime_format = \"%Y-%m-%d\"\ndate_query = start_date.strftime(time_format) + \"/\" + end_date.strftime(time_format)\n\n# Search for Sentinel-2 data\nitems = (\n    pystac_client.Client.open(\"https://earth-search.aws.element84.com/v1\")\n    .search(\n        bbox=bounds,\n        collections=[\"sentinel-2-l2a\"],\n        datetime=date_query,\n        limit=100,\n    )\n    .item_collection()\n)\nprint(len(items), \"scenes found\")\n\nWe will now focus on the area south-east of Vienna, where the Nationalpark Donauauen is situated. The time frame we are interested in is the beginning of May 2024.\nAfter passing these parameters to the stac-catalog we have found 10 scenes that we can use for our analysis.","type":"content","url":"/notebooks/templates/classification#searching-in-the-catalog","position":5},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Loading the Data","lvl2":"Data Acquisition"},"type":"lvl3","url":"/notebooks/templates/classification#loading-the-data","position":6},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Loading the Data","lvl2":"Data Acquisition"},"content":"Now we will load the data directly into an xarray dataset, which we can use to perform computations on the data. xarray is a powerful library for working with multi-dimensional arrays, making it well-suited for handling satellite data.\n\nHereâ€™s how we can load the data using odc-stac and xarray:\n\n# define a geobox for my region\ngeobox = GeoBox.from_bbox(bounds, crs=f\"epsg:{epsg}\", resolution=dx)\n\n# lazily combine items into a datacube\ndc = odc.stac.load(\n    items,\n    bands=[\"scl\", \"red\", \"green\", \"blue\", \"nir\"],\n    chunks={\"time\": 5, \"x\": 600, \"y\": 600},\n    geobox=geobox,\n    resampling=\"bilinear\",\n)\ndc\n\n","type":"content","url":"/notebooks/templates/classification#loading-the-data","position":7},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl2":"Data Visualization"},"type":"lvl2","url":"/notebooks/templates/classification#data-visualization","position":8},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl2":"Data Visualization"},"content":"","type":"content","url":"/notebooks/templates/classification#data-visualization","position":9},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"RGB Image","lvl2":"Data Visualization"},"type":"lvl3","url":"/notebooks/templates/classification#rgb-image","position":10},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"RGB Image","lvl2":"Data Visualization"},"content":"With the image data now in our possession, we can proceed with computations and visualizations.\n\nFirst, we define a mask to exclude cloud cover and areas with missing data. Subsequently, we create a composite median image, where each pixel value represents the median value across all the scenes we have identified. This approach helps to eliminate clouds and outliers present in some of the images, thereby providing a clearer and more representative visualization of the scene.\n\n# define a mask for valid pixels (non-cloud)\n\n\ndef is_valid_pixel(data):\n    # include only vegetated, not_vegitated, water, and snow\n    return ((data > 3) & (data < 7)) | (data == 11)\n\n\ndc[\"valid\"] = is_valid_pixel(dc.scl)\n\n# compute the masked median\nrgb_median = (\n    dc[[\"red\", \"green\", \"blue\"]]\n    .where(dc.valid)\n    .to_dataarray(dim=\"band\")\n    .median(dim=\"time\")\n    .astype(int)\n)\n\n# plot the median composite\ntitle_rgb = (\n    \"RGB - Median Composite\"\n    + f\"\\n{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}\"\n)\nrgb_median.plot.imshow(robust=True).axes.set_title(title_rgb)\nplt.show()\n\n","type":"content","url":"/notebooks/templates/classification#rgb-image","position":11},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"False Color Image","lvl2":"Data Visualization"},"type":"lvl3","url":"/notebooks/templates/classification#false-color-image","position":12},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"False Color Image","lvl2":"Data Visualization"},"content":"In addition to the regular RGB Image, we can swap any of the bands from the visible spectrum with any other bands. In this specific case the red band has been changed to the near infrared band. This allows us to see vegetated areas more clearly, since they now appear in a bright red color. This is due to the fact that plants absorb regular red light while reflecting near infrared light \n\nNASA, 2020.\n\n# compute a false color image\n# near infrared instead of red\nfc_median = (\n    dc[[\"nir\", \"green\", \"blue\"]]\n    .where(dc.valid)\n    .to_dataarray(dim=\"band\")\n    .transpose(..., \"band\")\n    .median(dim=\"time\")\n    .astype(int)\n)\n\ntitle_fc = (\n    \"False color - Median Composite\"\n    + f\"\\n{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}\"\n)\nfc_median.plot.imshow(robust=True).axes.set_title(title_fc)\nplt.show()\n\n","type":"content","url":"/notebooks/templates/classification#false-color-image","position":13},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"NDVI Image","lvl2":"Data Visualization"},"type":"lvl3","url":"/notebooks/templates/classification#ndvi-image","position":14},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"NDVI Image","lvl2":"Data Visualization"},"content":"To get an first impression of the data, we can calculate the NDVI (Normalized Difference Vegetation Index) and plot it. The NDVI is calculated by useing the following formula. \n\nRouse et al., 1974NDVI = \\frac{NIR - Red}{NIR + Red}\n\nThis gives us a good overview of the vegetation in the area. The values can range from -1 to 1 where the following meanings are associated with these values:\n\n-1 to 0 indicate dead plants or inanimate objects\n\n0 to 0.33 are unhealthy plants\n\n0.33 to 0.66 are moderatly healthy plants\n\n0.66 to 1 are very healthy plants\n\n# Normalized Difference Vegetation Index (NDVI)\n\n\ndef normalized_difference(a, b):\n    return (a - b * 1.0) / (a + b)\n\n\nndvi = normalized_difference(dc.nir, dc.red)\nndvi.median(dim=\"time\").plot.imshow(cmap=\"cmc.cork\", vmin=-1, vmax=1).axes.set_title(\n    \"NDVI\"\n)\nplt.show()\n\n","type":"content","url":"/notebooks/templates/classification#ndvi-image","position":15},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl2":"Classification"},"type":"lvl2","url":"/notebooks/templates/classification#classification","position":16},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl2":"Classification"},"content":"In this chapter, we will classify the satellite data to identify forested areas within the scene. By using supervised machine learning techniques, we can train classifiers to distinguish between forested and non-forested regions based on the training data we provide. We will explore two different classifiers and compare their performance in accurately identifying forest areas.","type":"content","url":"/notebooks/templates/classification#classification","position":17},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Regions of Interest","lvl2":"Classification"},"type":"lvl3","url":"/notebooks/templates/classification#regions-of-interest","position":18},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Regions of Interest","lvl2":"Classification"},"content":"Since this is a supervised classification, we need to have some training data. Therefore we need to define areas or regions, which we are certain represent the feature which we are classifiying. In this case we are interested in forested areas and regions that are definitly not forested. These regions will be used to train our classifiers.\n\n# Define Polygons\nforest_areas = {\n    0: [\n        Polygon(\n            [\n                (16.482772, 47.901753),\n                (16.465133, 47.870124),\n                (16.510142, 47.874382),\n                (16.482772, 47.901753),\n            ]\n        )\n    ],\n    1: [\n        Polygon(\n            [\n                (16.594079, 47.938855),\n                (16.581914, 47.894454),\n                (16.620233, 47.910268),\n                (16.594079, 47.938855),\n            ]\n        )\n    ],\n    2: [\n        Polygon(\n            [\n                (16.67984, 47.978998),\n                (16.637263, 47.971091),\n                (16.660376, 47.929123),\n                (16.67984, 47.978998),\n            ]\n        )\n    ],\n    3: [\n        Polygon(\n            [\n                (16.756477, 48.000286),\n                (16.723024, 47.983256),\n                (16.739446, 47.972916),\n                (16.756477, 48.000286),\n            ]\n        )\n    ],\n    4: [\n        Polygon(\n            [\n                (16.80696, 48.135923),\n                (16.780806, 48.125583),\n                (16.798445, 48.115243),\n                (16.80696, 48.135923),\n            ]\n        )\n    ],\n    5: [\n        Polygon(\n            [\n                (16.684097, 48.144438),\n                (16.664634, 48.124366),\n                (16.690788, 48.118892),\n                (16.684097, 48.144438),\n            ]\n        )\n    ],\n    6: [\n        Polygon(\n            [\n                (16.550894, 48.169984),\n                (16.530822, 48.165118),\n                (16.558801, 48.137139),\n                (16.550894, 48.169984),\n            ]\n        )\n    ],\n    7: [\n        Polygon(\n            [\n                (16.588604, 48.402329),\n                (16.556976, 48.401112),\n                (16.580697, 48.382865),\n                (16.588604, 48.402329),\n            ]\n        )\n    ],\n}\n\nnonforest_areas = {\n    0: [\n        Polygon(\n            [\n                (16.674974, 48.269126),\n                (16.623882, 48.236281),\n                (16.682272, 48.213168),\n                (16.674974, 48.269126),\n            ]\n        )\n    ],\n    1: [\n        Polygon(\n            [\n                (16.375723, 48.228374),\n                (16.357476, 48.188839),\n                (16.399444, 48.185798),\n                (16.375723, 48.228374),\n            ]\n        )\n    ],\n    2: [\n        Polygon(\n            [\n                (16.457834, 48.26426),\n                (16.418907, 48.267301),\n                (16.440804, 48.23324),\n                (16.457834, 48.26426),\n            ]\n        )\n    ],\n    3: [\n        Polygon(\n            [\n                (16.519266, 48.101861),\n                (16.470607, 48.100645),\n                (16.500411, 48.07145),\n                (16.519266, 48.101861),\n            ]\n        )\n    ],\n    4: [\n        Polygon(\n            [\n                (16.453577, 48.051986),\n                (16.412217, 48.067192),\n                (16.425598, 48.012451),\n                (16.453577, 48.051986),\n            ]\n        )\n    ],\n}\n\n# Geoppandas Dataframe from Polygons\nforest_df = gpd.GeoDataFrame(\n    {\"geometry\": [poly[0] for poly in forest_areas.values()]}, crs=\"EPSG:4326\"\n)\nnonforest_df = gpd.GeoDataFrame(\n    {\"geometry\": [poly[0] for poly in nonforest_areas.values()]},\n    crs=\"EPSG:4326\",\n)\n\n\n# Plotting Regions of Interest\nfig, ax = plt.subplots()\nrgb_median.plot.imshow(ax=ax, robust=True)\nforest_df.plot(ax=ax, ec=\"C0\", fc=\"none\")\nnonforest_df.plot(ax=ax, ec=\"C1\", fc=\"none\")\nax.set_title(\"Regions of Interest\")\nax.set_aspect(\"equal\")\nplt.show()\n\n","type":"content","url":"/notebooks/templates/classification#regions-of-interest","position":19},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Data Preparation","lvl2":"Classification"},"type":"lvl3","url":"/notebooks/templates/classification#data-preparation","position":20},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Data Preparation","lvl2":"Classification"},"content":"In addition to the Regions of Interest we will extract the specific bands from the loaded dataset that we intend to use for the classification, which are the red, green, blue and near-infrared bands, although other bands can also be utilized. Using these bands, we will create both a training and a testing dataset. The training dataset will be used to train the classifier, while the testing dataset will be employed to evaluate its performance.\n\n# Classifiying dataset (only necessary bands)\nbands = [\"red\", \"green\", \"blue\", \"nir\"]\nds_class = dc[bands].where(dc.valid).median(dim=\"time\")\nds_class = ds_class.fillna(0)\n\n\ndef clip_array(ds: xr.Dataset, polygons):\n    clipped = ds.rio.clip(polygons, invert=False, all_touched=False, drop=True)\n    clipped_nan = clipped.where(clipped == ds)\n    return clipped_nan\n\n\n# Dictionaries with Dataarrays, each clipped by a Polygon\ndata_dict_feat = {\n    idx: clip_array(ds_class, polygon) for idx, polygon in forest_areas.items()\n}\ndata_dict_nonfeat = {\n    idx: clip_array(ds_class, polygon) for idx, polygon in nonforest_areas.items()\n}\n\n# Reshape the polygon dataarrays to get a tuple (one value per band) of pixel values\nfeat_data = [\n    xarray.to_array().values.reshape(len(bands), -1).T\n    for xarray in data_dict_feat.values()\n]  # replaced median_data_dict_feat with data_dict_feat\nnonfeat_data = [\n    xarray.to_array().values.reshape(len(bands), -1).T\n    for xarray in data_dict_nonfeat.values()\n]  # replaced median_data_dict_feat with data_dict_feat\n\n# The rows of the different polygons are concatenated to a single array for further processing\nfeat_values = np.concatenate(feat_data)\nnonfeat_values = np.concatenate(nonfeat_data)\n\n# Drop Nan Values\nX_feat_data = feat_values[~np.isnan(feat_values).any(axis=1)]\nX_nonfeat_data = nonfeat_values[~np.isnan(nonfeat_values).any(axis=1)]\n\n# Creating Output Vector (1 for pixel is features; 0 for pixel is not feature)\ny_feat_data = np.ones(X_feat_data.shape[0])\ny_nonfeat_data = np.zeros(X_nonfeat_data.shape[0])\n\n# Concatenate all Classes for training\nX = np.concatenate([X_feat_data, X_nonfeat_data])\ny = np.concatenate([y_feat_data, y_nonfeat_data])\n\n# Split into Training and Testing Data.\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.5, random_state=42\n)\n\nNow that we have prepared the training and testing data, we will create an image array of the actual scene that we intend to classify. This array will serve as the input for our classification algorithms, allowing us to apply the trained classifiers to the entire scene and identify the forested and non-forested areas accurately.\n\nimage_data = (\n    ds_class[bands].to_array(dim=\"band\").transpose(\"latitude\", \"longitude\", \"band\")\n)\n\n# Reshape the image data\nnum_of_pixels = ds_class.sizes[\"longitude\"] * ds_class.sizes[\"latitude\"]\nnum_of_bands = len(bands)\nX_image_data = image_data.values.reshape(num_of_pixels, num_of_bands)\n\n","type":"content","url":"/notebooks/templates/classification#data-preparation","position":21},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Classifiying with Naive Bayes","lvl2":"Classification"},"type":"lvl3","url":"/notebooks/templates/classification#classifiying-with-naive-bayes","position":22},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Classifiying with Naive Bayes","lvl2":"Classification"},"content":"Now that we have prepared all the needed data, we can begin the actual classification process.\n\nWe will start with a Naive Bayes classifier. First, we will train the classifier using our training dataset. Once trained, we will apply the classifier to the actual image to identify the forested and non-forested areas.\n\n# Naive Bayes initialization and training\nnb = GaussianNB()\nnb_test = nb.fit(X_train, y_train)\nnb_predict = nb.predict(X_test)\n\n# Prediction on image\nnb_predict_img = nb.predict(X_image_data)\nnb_predict_img = nb_predict_img.reshape(\n    ds_class.sizes[\"latitude\"], ds_class.sizes[\"longitude\"]\n)\n\n# Adding the Naive Bayes Prediction to the dataset\nds_class[\"NB-forest\"] = xr.DataArray(\n    nb_predict_img,\n    dims=[\"latitude\", \"longitude\"],\n    coords={\n        \"longitude\": ds_class[\"longitude\"],\n        \"latitude\": ds_class[\"latitude\"],\n    },\n)\n\nTo evaluate the effectiveness of the classification, we will plot the image predicted by the classifier. Additionally, we will examine the Classification Report and the Confusion Matrix to gain further insights into the classifierâ€™s performance.\n\n# Plot Naive Bayes\nalpha = 1\ncmap_green = colors.ListedColormap([(1, 1, 1, alpha), \"green\"])\n\nplot = ds_class[\"NB-forest\"].plot.imshow(\n    cmap=cmap_green, cbar_kwargs={\"ticks\": [0.25, 0.75]}\n)\ncbar = plot.colorbar\ncbar.set_ticklabels([\"non-forest\", \"forest\"])\nplot.axes.set_title(\"Naive Bayes Classification\")\nplt.show()\n\n# Print the Classification report\nprint(\"NAIVE BAYES: \\n \" + classification_report(y_test, nb_predict))\n\n# Print the confusion matrix\ncon_mat_nb = pd.DataFrame(\n    confusion_matrix(y_test, nb_predict),\n    index=[\"Actual Negative\", \"Actual Positive\"],\n    columns=[\"Predicted Negative\", \"Predicted Positive\"],\n)\ndisplay(con_mat_nb)\n\n","type":"content","url":"/notebooks/templates/classification#classifiying-with-naive-bayes","position":23},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Classifiying with Random Forest","lvl2":"Classification"},"type":"lvl3","url":"/notebooks/templates/classification#classifiying-with-random-forest","position":24},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Classifiying with Random Forest","lvl2":"Classification"},"content":"To ensure our results are robust, we will explore an additional classifier. In this section, we will use the Random Forest classifier. The procedure for using this classifier is the same as before: we will train the classifier using our training dataset and then apply it to the actual image to classify the scene.\n\n# Random Forest initialization and training\nrf = RandomForestClassifier(n_estimators=100)\nrf_test = rf.fit(X_train, y_train)\nrf_predict = rf.predict(X_test)\n\n# Prediction on image\nrf_predict_img = rf.predict(X_image_data)\nrf_predict_img = rf_predict_img.reshape(\n    ds_class.sizes[\"latitude\"], ds_class.sizes[\"longitude\"]\n)\n\n# Adding the Random Forest Prediction to the dataset\nds_class[\"RF-forest\"] = xr.DataArray(\n    rf_predict_img,\n    dims=[\"latitude\", \"longitude\"],\n    coords={\n        \"longitude\": ds_class[\"longitude\"],\n        \"latitude\": ds_class[\"latitude\"],\n    },\n)\n\nplot = ds_class[\"RF-forest\"].plot.imshow(\n    cmap=cmap_green, cbar_kwargs={\"ticks\": [0.25, 0.75]}\n)\ncbar = plot.colorbar\ncbar.set_ticklabels([\"non-forest\", \"forest\"])\nplot.axes.set_title(\"Random Forest Classification\")\nplt.show()\n\n# Print the Classification report\nprint(\"RANDOM FOREST: \\n \" + classification_report(y_test, rf_predict))\n\n# Print the confusion matrix\ncon_mat_rf = pd.DataFrame(\n    confusion_matrix(y_test, rf_predict),\n    index=[\"Actual Negative\", \"Actual Positive\"],\n    columns=[\"Predicted Negative\", \"Predicted Positive\"],\n)\ndisplay(con_mat_rf)\n\nWe can already see from the classification reports and the confusion matrices that the Random Forest classifier has outperformed the Naive Bayes classifier. This is particularly evident from the lower values in the secondary diagonal, indicating minimal False Positives and False Negatives. It appears that the Naive Bayes classifier is more sensitive to False Positives, resulting in a higher rate of incorrect classifications.","type":"content","url":"/notebooks/templates/classification#classifiying-with-random-forest","position":25},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Comparison of the Classificators","lvl2":"Classification"},"type":"lvl3","url":"/notebooks/templates/classification#comparison-of-the-classificators","position":26},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl3":"Comparison of the Classificators","lvl2":"Classification"},"content":"To gain a more in-depth understanding of the classifiersâ€™ performance, we will compare their results. Specifically, we will identify the areas where both classifiers agree and the areas where they disagree. This comparison will provide valuable insights into the strengths and weaknesses of each classifier, allowing us to better assess their effectiveness in identifying forested and non-forested regions.\n\ncmap_trio = colors.ListedColormap([\"whitesmoke\", \"indianred\", \"goldenrod\", \"darkgreen\"])\n\n\ndouble_clf = ds_class[\"NB-forest\"] + 2 * ds_class[\"RF-forest\"]\n\nfig, ax = plt.subplots()\ncax = ax.imshow(double_clf, cmap=cmap_trio, interpolation=\"none\")\n\n# Add a colorbar with custom tick labels\ncbar = fig.colorbar(cax, ticks=[1 * 0.375, 3 * 0.375, 5 * 0.375, 7 * 0.375])\ncbar.ax.set_yticklabels([\"None\", \"Naive Bayes\", \"Random Forest\", \"Both\"])\nax.set_title(\"Classification Comparisson\")\nax.set_axis_off()\nplt.show()\n\nThe areas where both classifiers agree include the larger forested regions, such as the Nationalpark Donau-Auen and the Leithagebirge. Additionally, both classifiers accurately identified the urban areas of Vienna and correctly excluded them from being classified as forested.\n\n# Plot only one class, either None (0), Naive Bayes (1), Random Forest (2), or Both (3)\nfig, axs = plt.subplots(2, 2, figsize=(8, 8))\nax = axs.ravel()\n\nfor i in range(4):\n    ax[i].imshow(double_clf == i, cmap=\"cmc.oleron_r\", interpolation=\"none\")\n    category = [\n        \"by None\",\n        \"only by Naive Bayes\",\n        \"only by Random Forest\",\n        \"by Both\",\n    ][i]\n    title = \"Areas classified \" + category\n    ax[i].set_title(title)\n    ax[i].set_axis_off()\n\nplt.tight_layout()\n\nWhen plotting the classified areas individually, we observe that the Random Forest classifier mistakenly identified the Danube River as a forested area. Conversely, the Naive Bayes classifier erroneously classified a significant amount of cropland as forest.\n\nFinally, by analyzing the proportion of forested areas within the scene, we find that approximately 18% of the area is classified as forest, while around 66% is classified as non-forest. The remaining areas, which include water bodies and cropland, fall into less clearly defined categories.\n\nThe accompanying bar chart illustrates the distribution of these classifications, highlighting the percentage of forested areas, non-forested areas, and regions classified by only one of the two classifiers. This visual representation helps to quantify the areas of agreement and disagreement between the classifiers, providing a clearer picture of their performance.\n\ncounts = {}\nfor num in range(0, 4):\n    num_2_class = {0: \"None\", 1: \"Naive Bayes\", 2: \"Random Forest\", 3: \"Both\"}\n    counts[num_2_class[num]] = int((double_clf == num).sum().values)\n\nclass_counts_df = pd.DataFrame(list(counts.items()), columns=[\"Class\", \"Count\"])\nclass_counts_df[\"Percentage\"] = (\n    class_counts_df[\"Count\"] / class_counts_df[\"Count\"].sum()\n) * 100\nax = class_counts_df.plot.bar(\n    x=\"Class\",\n    y=\"Percentage\",\n    rot=0,\n    color=\"darkgreen\",\n    ylim=(0, 100),\n    title=\"Classified Areas per Classificator (%)\",\n)\n\n# Annotate the bars with the percentage values\nfor p in ax.patches:\n    ax.annotate(\n        f\"{p.get_height():.1f}%\",\n        (p.get_x() + p.get_width() / 2.0, p.get_height()),\n        ha=\"center\",\n        va=\"center\",\n        xytext=(0, 9),\n        textcoords=\"offset points\",\n    )\n\n","type":"content","url":"/notebooks/templates/classification#comparison-of-the-classificators","position":27},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl2":"Conclusion"},"type":"lvl2","url":"/notebooks/templates/classification#conclusion","position":28},{"hierarchy":{"lvl1":"Classification of Sentinel-2 imagery","lvl2":"Conclusion"},"content":"In this chapter, we utilized machine learning to classify satellite imagery into forested and non-forested areas, comparing Naive Bayes and Random Forest classifiers. The Random Forest classifier generally outperformed Naive Bayes, with fewer errors in classification, although it misclassified the Danube River as forested, while Naive Bayes incorrectly identified cropland as forest. The analysis, supported by the bar chart, revealed that about 18% of the scene was classified as forest, 66% as non-forest, and the remainder included ambiguous categories. This comparison highlights the strengths and limitations of each classifier, underscoring the need for careful selection and evaluation of classification methods.","type":"content","url":"/notebooks/templates/classification#conclusion","position":29},{"hierarchy":{"lvl1":"Templates"},"type":"lvl1","url":"/notebooks/templates/prereqs-templates","position":0},{"hierarchy":{"lvl1":"Templates"},"content":"This section of the Cookbook covers a wide range of topics. The intent is to\ncreate templates to showcase workflows that can be used by students as a primer\nfor independent research projects.\n\nConcepts\n\nImportance\n\nNotes\n\nIntro to xarray\n\nNecessary\n\n\n\nDask Arrays\n\nNecessary\n\n\n\nDocumentation scikit-learn\n\nNeccesary\n\nMachine Learning in Python\n\nDocumentation Matplotlib\n\nHelpful\n\nPloting in Python\n\nDocumentation odc-stac\n\nHelpful\n\nData access\n\nTime to learn: 10 min","type":"content","url":"/notebooks/templates/prereqs-templates","position":1},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection"},"type":"lvl1","url":"/notebooks/tutorials/floodmapping","position":0},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection"},"content":"How an 275 year old idea helps map the extent of floods\n\nNote\n\nThis notebook contains interactive elements. The full interactive elements can only be viewed on Binder by clicking on the Binder badge or ğŸš€ button.","type":"content","url":"/notebooks/tutorials/floodmapping","position":1},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Overview"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#overview","position":2},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Overview"},"content":"This notebook explains how microwave (\\sigma^0) backscattering can be used to map the extent of a flood. We replicate in this exercise the work of \n\nBauer-Marschallinger et al., 2022 on the TU Wien Bayesian-based flood mapping algorithm.","type":"content","url":"/notebooks/tutorials/floodmapping#overview","position":3},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Prerequisites"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#prerequisites","position":4},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Prerequisites"},"content":"Concepts\n\nImportance\n\nNotes\n\nIntro to xarray\n\nNecessary\n\n\n\nIntro to Harmonic parameters\n\nNecessary\n\n\n\nDocumentation hvPlot\n\nHelpful\n\nInteractive plotting\n\nDocumentation odc-stac\n\nHelpful\n\nData access\n\nTime to learn: 10 min","type":"content","url":"/notebooks/tutorials/floodmapping#prerequisites","position":5},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Imports"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#imports","position":6},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Imports"},"content":"\n\nimport datetime\n\nimport holoviews as hv\nimport hvplot.pandas\nimport hvplot.xarray\nimport numpy as np\nimport pandas as pd\nimport panel as pn\nimport pystac_client\nimport rioxarray  # noqa: F401\nimport xarray as xr\nfrom bokeh.models import FixedTicker\nfrom odc import stac as odc_stac\nfrom scipy.stats import norm\n\npn.extension()\nhv.extension(\"bokeh\")\n\n","type":"content","url":"/notebooks/tutorials/floodmapping#imports","position":7},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Greece Flooding 2018"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#greece-flooding-2018","position":8},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Greece Flooding 2018"},"content":"In this exercise we will replicate the case study of the above mentioned paper, the February 2018 flooding of the Greek region of Thessaly.\n\ntime_range = \"2018-02-28T04:00:00Z/2018-02-28T05:00:00Z\"\nminlon, maxlon = 21.93, 22.23\nminlat, maxlat = 39.47, 39.64\nbounding_box = [minlon, minlat, maxlon, maxlat]\n\n","type":"content","url":"/notebooks/tutorials/floodmapping#greece-flooding-2018","position":9},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"EODC STAC Catalog"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#eodc-stac-catalog","position":10},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"EODC STAC Catalog"},"content":"The data required for TU Wien flood mapping algorithm consists of terrain corrected sigma naught backscatter data \\sigma^{0}, the projected local incidence angle (PLIA) values of those measurements, and the harmonic parameters (HPAR) of a model fit on the pixelâ€™s backscatter time series. The latter two datasets will needed to calculate the probability density functions over land and water for. We will be getting the required data from the EODC STAC Catalog. Specifically the collections: SENTINEL_SIG0_20M, SENTINEL1_MPLIA and SENTINEL1_HPAR. We use the pystac-client and odc_stac packages to, respectively, discover and fetch the data.\n\nDue to the way the data is acquired and stored, some items include â€œno dataâ€ areas. In our case, no data has the value -9999, but this can vary from data provider to data provider. This information can usually be found in the metadata. Furthermore, to save memory, data is often stored as integer (e.g. 25) and not in float (e.g. 2.5) format. For this reason, the backscatter values are often multiplied by a scale factor. Hence we define the function post_process_eodc_cube to correct for these factors as obtained from the STAC metadata.","type":"content","url":"/notebooks/tutorials/floodmapping#eodc-stac-catalog","position":11},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl3":"Sigma naught","lvl2":"EODC STAC Catalog"},"type":"lvl3","url":"/notebooks/tutorials/floodmapping#sigma-naught","position":12},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl3":"Sigma naught","lvl2":"EODC STAC Catalog"},"content":"\n\neodc_catalog = pystac_client.Client.open(\"https://stac.eodc.eu/api/v1\")\nsearch = eodc_catalog.search(\n    collections=\"SENTINEL1_SIG0_20M\",\n    bbox=bounding_box,\n    datetime=time_range,\n)\nitems_sig0 = search.item_collection()\n\n\ndef post_process_eodc_cube(dc, items, bands):\n    \"\"\"\n    Postprocessing of EODC data cubes.\n\n    Parameters\n    ----------\n    x : xarray.Dataset\n    items: pystac.item_collection.ItemCollection\n        STAC items that concern the Xarray Dataset\n    bands: array\n        Selected bands\n\n    Returns\n    -------\n    xarray.Dataset\n    \"\"\"\n    if not isinstance(bands, tuple):\n        bands = tuple([bands])\n    for i in bands:\n        dc[i] = post_process_eodc_cube_(dc[i], items, i)\n    return dc\n\n\ndef post_process_eodc_cube_(dc, items, band):\n    fields = items[0].assets[band].extra_fields\n    scale = fields.get(\"raster:bands\")[0][\"scale\"]\n    nodata = fields.get(\"raster:bands\")[0][\"nodata\"]\n    return dc.where(dc != nodata) / scale\n\n\nbands = \"VV\"\nsig0_dc = odc_stac.load(items_sig0, bands=bands, bbox=bounding_box)\nsig0_dc = (\n    post_process_eodc_cube(sig0_dc, items_sig0, bands)\n    .rename_vars({\"VV\": \"sig0\"})\n    .dropna(dim=\"time\", how=\"all\")\n    .median(\"time\")\n)\n\nsig0_dc\n\n","type":"content","url":"/notebooks/tutorials/floodmapping#sigma-naught","position":13},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl3":"Harmonic Parameters","lvl2":"EODC STAC Catalog"},"type":"lvl3","url":"/notebooks/tutorials/floodmapping#harmonic-parameters","position":14},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl3":"Harmonic Parameters","lvl2":"EODC STAC Catalog"},"content":"\n\nsearch = eodc_catalog.search(\n    collections=\"SENTINEL1_HPAR\",\n    bbox=bounding_box,\n    query=[\"sat:relative_orbit=80\"],\n)\n\nitems_hpar = search.item_collection()\nbands = (\"C1\", \"C2\", \"C3\", \"M0\", \"S1\", \"S2\", \"S3\", \"STD\")\nhpar_dc = odc_stac.load(\n    items_hpar,\n    bands=bands,\n    bbox=bounding_box,\n    groupby=None,\n)\nhpar_dc = post_process_eodc_cube(hpar_dc, items_hpar, bands).median(\"time\")\nhpar_dc\n\n","type":"content","url":"/notebooks/tutorials/floodmapping#harmonic-parameters","position":15},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl3":"Projected Local Incidence Angles","lvl2":"EODC STAC Catalog"},"type":"lvl3","url":"/notebooks/tutorials/floodmapping#projected-local-incidence-angles","position":16},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl3":"Projected Local Incidence Angles","lvl2":"EODC STAC Catalog"},"content":"\n\nsearch = eodc_catalog.search(\n    collections=\"SENTINEL1_MPLIA\",\n    bbox=bounding_box,\n    query=[\"sat:relative_orbit=80\"],\n)\n\nitems_plia = search.item_collection()\n\nbands = \"MPLIA\"\nplia_dc = odc_stac.load(\n    items_plia,\n    bands=bands,\n    bbox=bounding_box,\n)\n\nplia_dc = post_process_eodc_cube(plia_dc, items_plia, bands).median(\"time\")\nplia_dc\n\nFinally, we merged the datasets as one big dataset and reproject the data in EPSG 4326 for easier visualizing of the data.\n\nflood_dc = xr.merge([sig0_dc, plia_dc, hpar_dc])\nflood_dc = flood_dc.rio.reproject(\"EPSG:4326\").rio.write_crs(\"EPSG:4326\")\nflood_dc\n\n","type":"content","url":"/notebooks/tutorials/floodmapping#projected-local-incidence-angles","position":17},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"From Backscattering to Flood Mapping"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#from-backscattering-to-flood-mapping","position":18},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"From Backscattering to Flood Mapping"},"content":"In the following lines we create a map with microwave backscattering values.\n\nmrs_view = flood_dc.sig0.hvplot.image(\n    x=\"x\", y=\"y\", cmap=\"viridis\", geo=True, tiles=True\n).opts(frame_height=400)\nmrs_view\n\nFigureÂ 1:Area targeted for \\sigma^0 backscattering is the Greek region of Thessaly, which experienced a major flood in February of 2018.\n\n","type":"content","url":"/notebooks/tutorials/floodmapping#from-backscattering-to-flood-mapping","position":19},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Microwave Backscattering over Land and Water"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#microwave-backscattering-over-land-and-water","position":20},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Microwave Backscattering over Land and Water"},"content":"Reverend Bayes was concerned with two events, one (the hypothesis) occurring before the other (the evidence). If we know its cause, it is easy to logically deduce the probability of an effect. However, in this case we want to deduce the probability of a cause from an observed effect, also known as â€œreversed probabilityâ€. In the case of flood mapping, we have \\sigma^0 backscatter observations over land (the effect) and we want to deduce the probability of flooding (F) and non-flooding (NF).\n\nIn other words, we want to know the probability of flooding P(F) given a pixelâ€™s \\sigma^0:P(F|\\sigma^0)\n\nand the probability of a pixel being not flooded P(NF) given a certain \\sigma^0:P(NF|\\sigma^0).\n\nBayes showed that these can be deduced from the observation that forward and reversed probability are equal, so that:P(F|\\sigma^0)P(\\sigma^0) = P(\\sigma^0|F)P(F)\n\nandP(NF|\\sigma^0)P(\\sigma^0) = P(\\sigma^0|NF)P(NF).\n\nThe forward probability of \\sigma^0 given the occurrence of flooding (P(\\sigma^0|F)) and \\sigma^0 given no flooding (P(\\sigma^0|NF)) can be extracted from past information on backscattering over land and water surfaces. As seen in the sketch below , the characteristics of backscattering over land and water differ considerably.\n\n{#fig-sat}","type":"content","url":"/notebooks/tutorials/floodmapping#microwave-backscattering-over-land-and-water","position":21},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Likelihoods"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#likelihoods","position":22},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Likelihoods"},"content":"The so-called likelihoods of P(\\sigma^0|F) and P(\\sigma^0|NF) can thus be calculated from past backscattering information. In the following code chunk we define the functions calc_water_likelihood and calc_land_likelihood to calculate the water and land likelihoodâ€™s of a pixel, based on the Xarray datasets for the PLIA and HPAR, respectively.\n\ndef calc_water_likelihood(sigma, x=None, y=None):\n    \"\"\"\n    Calculate water likelihoods.\n\n    Parameters\n    ----------\n    sigma: float|array\n        Sigma naught value(s)\n    x: float|array\n        Longitude\n    y: float|array\n        Latitude\n\n    Returns\n    -------\n    numpy array\n    \"\"\"\n    point = flood_dc.sel(x=x, y=y, method=\"nearest\")\n    wbsc_mean = point.MPLIA * -0.394181 + -4.142015\n    wbsc_std = 2.754041\n    return norm.pdf(sigma, wbsc_mean.to_numpy(), wbsc_std)\n\n\ndef expected_land_backscatter(data, dtime_str):\n    w = np.pi * 2 / 365\n    dt = datetime.datetime.strptime(dtime_str, \"%Y-%m-%d\")\n    t = dt.timetuple().tm_yday\n    wt = w * t\n\n    M0 = data.M0\n    S1 = data.S1\n    S2 = data.S2\n    S3 = data.S3\n    C1 = data.C1\n    C2 = data.C2\n    C3 = data.C3\n    hm_c1 = (M0 + S1 * np.sin(wt)) + (C1 * np.cos(wt))\n    hm_c2 = (hm_c1 + S2 * np.sin(2 * wt)) + C2 * np.cos(2 * wt)\n    hm_c3 = (hm_c2 + S3 * np.sin(3 * wt)) + C3 * np.cos(3 * wt)\n    return hm_c3\n\n\ndef calc_land_likelihood(sigma, x=None, y=None):\n    \"\"\"\n    Calculate land likelihoods.\n\n    Parameters\n    ----------\n    sigma: float|array\n        Sigma naught value(s)\n    x: float|array\n        Longitude\n    y: float|array\n        Latitude\n\n    Returns\n    -------\n    numpy array\n    \"\"\"\n    point = flood_dc.sel(x=x, y=y, method=\"nearest\")\n    lbsc_mean = expected_land_backscatter(point, \"2018-02-01\")\n    lbsc_std = point.STD\n    return norm.pdf(sigma, lbsc_mean.to_numpy(), lbsc_std.to_numpy())\n\nWithout going into the details of how these likelihoods are calculated, you can hover over a pixel of the map to plot the likelihoods of \\sigma^0 being governed by land or water. For reference we model the water and land likelihoods (model_likelihoods) over a range of \\sigma^0 values.\n\ndef model_likelihoods(sigma=(-30, 0), x=None, y=None):\n    \"\"\"\n    Model likelihoods over a range of sigma naught.\n\n    Parameters\n    ----------\n    sigma: tuple\n        Minimum and maximum for range of sigma naught values\n    x: float|array\n        Longitude\n    y: float|array\n        Latitude\n\n    Returns\n    -------\n    Pandas Datafrane\n    \"\"\"\n    sigma = np.arange(sigma[0], sigma[1], 0.1)\n    land_likelihood = calc_land_likelihood(sigma=sigma, x=x, y=y)\n    water_likelihood = calc_water_likelihood(sigma=sigma, x=x, y=y)\n    point = flood_dc.sel(x=x, y=y, method=\"nearest\")\n    return pd.DataFrame(\n        {\n            \"sigma\": sigma,\n            \"water_likelihood\": water_likelihood,\n            \"land_likelihood\": land_likelihood,\n            \"observed\": np.repeat(point.sig0.values, len(land_likelihood)),\n        }\n    )\n\n\npointer = hv.streams.PointerXY(source=mrs_view.get(1), x=22.1, y=39.5)\n\nlikelihood_pdi = hvplot.bind(\n    model_likelihoods, x=pointer.param.x, y=pointer.param.y\n).interactive()\n\nview_likelihoods = (\n    likelihood_pdi.hvplot(\"sigma\", \"water_likelihood\", ylabel=\"likelihoods\").dmap()\n    * likelihood_pdi.hvplot(\"sigma\", \"land_likelihood\").dmap()\n    * likelihood_pdi.hvplot(\"observed\", \"land_likelihood\").dmap()\n).opts(frame_height=200, frame_width=300)\n\nview_likelihoods + mrs_view.get(1)\n\nFigureÂ 2:Likelihoods for \\sigma^0 being associated with land or water for 1 pixel in the Greek area of Thessaly. Likelihoods are calculated over a range of \\sigma^0. The pixelâ€™s observed \\sigma^0 is given with a vertical line. Hover on the map to re-calculate and update this figure for another pixel in the study area.\n\n","type":"content","url":"/notebooks/tutorials/floodmapping#likelihoods","position":23},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Posteriors"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#posteriors","position":24},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Posteriors"},"content":"Having calculated the likelihoods, we can now move on to calculate the probability of (non-)flooding given a pixelâ€™s \\sigma^0. These so-called posteriors need one more piece of information, as can be seen in the equation above. We need the probability that a pixel is flooded P(F) or not flooded P(NF). Of course, these are the figures weâ€™ve been trying to find this whole time. We donâ€™t actually have them yet, so what can we do? In Bayesian statistics, we can just start with our best guess. These guesses are called our â€œpriorsâ€, because they are the beliefs we hold prior to looking at the data. This subjective prior belief is the foundation Bayesian statistics, and we use the likelihoods we just calculated to update our belief in this particular hypothesis. This updated belief is called the â€œposteriorâ€.\n\nLetâ€™s say that our best estimate for the chance of flooding versus non-flooding of a pixel is 50-50: a coin flip.  We now can also calculate the probability of backscattering P(\\sigma^0), as the weighted average of the water and land likelihoods, ensuring that our posteriors range between 0 to 1.\n\nThe following code block shows how we calculate the priors.\n\ndef calc_posteriors(sigma, x=None, y=None):\n    \"\"\"\n    Calculate posterior probability.\n\n    Parameters\n    ----------\n    sigma: float|array\n        Sigma naught value(s)\n    x: float|array\n        Longitude\n    y: float|array\n        Latitude\n\n    Returns\n    -------\n    Tuple of two Numpy arrays\n    \"\"\"\n    land_likelihood = calc_land_likelihood(sigma=sigma, x=x, y=y)\n    water_likelihood = calc_water_likelihood(sigma=sigma, x=x, y=y)\n    evidence = (water_likelihood * 0.5) + (land_likelihood * 0.5)\n    water_posterior = (water_likelihood * 0.5) / evidence\n    land_posterior = (land_likelihood * 0.5) / evidence\n    return water_posterior, land_posterior\n\nWe can plot the posterior probabilities of flooding and non-flooding again and compare these to pixelâ€™s measured \\sigma^0. For reference we model the flood and non-flood posteriors (model_posteriors) over a range of \\sigma^0 values. Hover on a pixel to calculate the posterior probability.\n\ndef model_posteriors(sigma=(-30, 0), x=None, y=None):\n    \"\"\"\n    Model posterior probabilities over a range of sigma naught.\n\n    Parameters\n    ----------\n    sigma: tuple\n        Minimum and maximum for range of sigma naught values\n    x: float|array\n        Longitude\n    y: float|array\n        Latitude\n\n    Returns\n    -------\n    Pandas Datafrane\n    \"\"\"\n    bays_pd = model_likelihoods(sigma=sigma, x=x, y=y)\n    sigma = np.arange(sigma[0], sigma[1], 0.1)\n    bays_pd[\"f_post_prob\"], bays_pd[\"nf_post_prob\"] = calc_posteriors(\n        sigma=sigma, x=x, y=y\n    )\n    return bays_pd\n\n\nposterior_pdi = hvplot.bind(\n    model_posteriors, x=pointer.param.x, y=pointer.param.y\n).interactive()\n\nview_posteriors = (\n    posterior_pdi.hvplot(\"sigma\", \"f_post_prob\", ylabel=\"posteriors\").dmap()\n    * posterior_pdi.hvplot(\"sigma\", \"nf_post_prob\").dmap()\n    * posterior_pdi.hvplot(\"observed\", \"nf_post_prob\").dmap()\n).opts(frame_height=200, frame_width=300)\n\n(view_likelihoods + view_posteriors).cols(1) + mrs_view.get(1)\n\nFigureÂ 3:Posterior probabilities for \\sigma^0 of 1 pixel being associated with land for water in the Greek area of Thessaly. Hover on the map to re-calculate and update this figure for another pixel in the study area.\n\n","type":"content","url":"/notebooks/tutorials/floodmapping#posteriors","position":25},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Flood Classification"},"type":"lvl2","url":"/notebooks/tutorials/floodmapping#flood-classification","position":26},{"hierarchy":{"lvl1":"Reverend Bayes updates our Belief in Flood Detection","lvl2":"Flood Classification"},"content":"We are now ready to combine all this information and classify the pixels according to the probability of flooding given the backscatter value of each pixel. Here we just look whether the probability of flooding is higher than non-flooding:\n\ndef bayesian_flood_decision(sigma, x=None, y=None):\n    \"\"\"\n    Bayesian decision.\n\n    Parameters\n    ----------\n    sigma: float|array\n        Sigma naught value(s)\n    x: float|array\n        Longitude\n    y: float|array\n        Latitude\n\n    Returns\n    -------\n    Xarray DataArray\n    \"\"\"\n    f_post_prob, nf_post_prob = calc_posteriors(sigma=sigma, x=x, y=y)\n    return xr.where(\n        np.isnan(f_post_prob) | np.isnan(nf_post_prob),\n        np.nan,\n        np.greater(f_post_prob, nf_post_prob),\n    )\n\nHover on a point in the below map to see the likelihoods and posterior distributions (in the left-hand subplots).\n\nflood_dc[\"decision\"] = (\n    (\"y\", \"x\"),\n    bayesian_flood_decision(flood_dc.sig0, flood_dc.x, flood_dc.y),\n)\n\ncolorbar_opts = {\n    \"major_label_overrides\": {\n        0: \"non-flood\",\n        1: \"flood\",\n    },\n    \"ticker\": FixedTicker(ticks=[0, 1]),\n}\nflood_view = flood_dc.decision.hvplot.image(\n    x=\"x\", y=\"y\", rasterize=True, geo=True, cmap=[\"rgba(0, 0, 1, 0.1)\", \"darkred\"]\n).opts(frame_height=400, colorbar_opts={**colorbar_opts})\nmrs_view.get(0) * flood_view\n\nFigureÂ 4:Flood extent of the Greek region of Thessaly based on Bayesian probabilities are shown on the map superimposed on an open street map. Hover over a pixel to generate the pointâ€™s water and land likelihoods as well as the posterior probabilities.","type":"content","url":"/notebooks/tutorials/floodmapping#flood-classification","position":27},{"hierarchy":{"lvl1":"Tutorials"},"type":"lvl1","url":"/notebooks/tutorials/prereqs-tutorials","position":0},{"hierarchy":{"lvl1":"Tutorials"},"content":"This section of the Cookbook covers a wide range of topics. They showcase the\ncreation and usage of data products developed by TU Wien and EODC.","type":"content","url":"/notebooks/tutorials/prereqs-tutorials","position":1}]}