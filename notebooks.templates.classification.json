{"version":3,"kind":"Notebook","sha256":"2101497368618ac0549a0c6e36b2996b558676dca082bd4be95fddf7103cc6f6","slug":"notebooks.templates.classification","location":"/notebooks/templates/classification.ipynb","dependencies":[],"frontmatter":{"title":"Classification of Sentinel-2 imagery","content_includes_title":false,"kernelspec":{"name":"python3","display_name":"Python 3 (ipykernel)","language":"python"},"authors":[{"nameParsed":{"literal":"Wolfgang Wagner","given":"Wolfgang","family":"Wagner"},"name":"Wolfgang Wagner","id":"contributors-myst-generated-uid-0"},{"nameParsed":{"literal":"Martin Schobben","given":"Martin","family":"Schobben"},"name":"Martin Schobben","id":"contributors-myst-generated-uid-1"},{"nameParsed":{"literal":"Nikolas Pikall","given":"Nikolas","family":"Pikall"},"name":"Nikolas Pikall","id":"contributors-myst-generated-uid-2"},{"nameParsed":{"literal":"Joseph Wagner","given":"Joseph","family":"Wagner"},"name":"Joseph Wagner","id":"contributors-myst-generated-uid-3"},{"nameParsed":{"literal":"Davide Festa","given":"Davide","family":"Festa"},"name":"Davide Festa","id":"contributors-myst-generated-uid-4"},{"nameParsed":{"literal":"Felix David Reuß","given":"Felix David","family":"Reuß"},"name":"Felix David Reuß","id":"contributors-myst-generated-uid-5"},{"nameParsed":{"literal":"Luka Jović","given":"Luka","family":"Jović"},"name":"Luka Jović","id":"contributors-myst-generated-uid-6"}],"open_access":true,"license":{"content":{"id":"CC-BY-4.0","url":"https://creativecommons.org/licenses/by/4.0/","name":"Creative Commons Attribution 4.0 International","free":true,"CC":true},"code":{"id":"Apache-2.0","url":"https://opensource.org/licenses/Apache-2.0","name":"Apache License 2.0","free":true,"osi":true}},"copyright":"2024","affiliations":[{"id":"UAlbany","name":"University at Albany (SUNY)","department":"Atmospheric and Environmental Sciences","url":"https://www.albany.edu/daes"},{"id":"CISL","name":"NSF National Center for Atmospheric Research","department":"Computational and Information Systems Lab","url":"https://www.cisl.ucar.edu"},{"id":"Unidata","name":"NSF Unidata","url":"https://www.unidata.ucar.edu"},{"id":"Argonne","name":"Argonne National Laboratory","department":"Environmental Science Division","url":"https://www.anl.gov/evs"},{"id":"CarbonPlan","name":"CarbonPlan","url":"https://carbonplan.org"},{"id":"NVIDIA","name":"NVIDIA Corporation","url":"https://www.nvidia.com/"}],"numbering":{"title":{"offset":2}},"exports":[{"format":"ipynb","filename":"classification.ipynb","url":"/eo-datascience-cookbook/build/classification-12d57a525585f7e6aaa39b59b26ad8db.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"strong","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"Finding forests with satellite imagery","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"eaEwBJPsYt"}],"key":"WaA8ebtBUG"}],"key":"Ot9srQhzcz"},{"type":"heading","depth":2,"position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Data Acquisition","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"JLeRfCn6qd"}],"identifier":"data-acquisition","label":"Data Acquisition","html_id":"data-acquisition","implicit":true,"key":"RF0CUWP9df"},{"type":"paragraph","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"text","value":"In this chapter, we will employ machine learning techniques to classify a scene using satellite imagery. Specifically, we will utilize ","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"TtHTm5aH7b"},{"type":"inlineCode","value":"scikit-learn","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"OBVOcMRpxQ"},{"type":"text","value":" to implement two distinct classifiers and subsequently compare their results. To begin, we need to import the following modules.","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"rOSrLVyBXi"}],"key":"Hh2lHYwTiQ"}],"key":"SgHi2qgE0s"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"from datetime import datetime, timedelta\n\nimport cmcrameri as cmc  # noqa: F401\nimport geopandas as gpd\nimport matplotlib.colors as colors\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport odc.stac\nimport pandas as pd\nimport pystac_client\nimport rioxarray  # noqa: F401\nimport xarray as xr\nfrom odc.geo.geobox import GeoBox\nfrom shapely.geometry import Polygon\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.naive_bayes import GaussianNB","key":"DbzpAHuXq9"},{"type":"outputs","id":"LDb4ZMS_1aZA6numd1vJo","children":[],"key":"UX1yYJ5MRL"}],"key":"nj12Vk2svH"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Before we start, we need to load the data. We will use ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"JTKLVVGWxR"},{"type":"inlineCode","value":"odc-stac","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"awOGUVSZ10"},{"type":"text","value":" to obtain data from Earth Search by Element 84. Here we define the area of interest and the time frame, aswell as the EPSG code and the resolution.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"zGVl1Vr1E8"}],"key":"bjjQHIeZj5"},{"type":"heading","depth":3,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Searching in the Catalog","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"ywqDEy1ink"}],"identifier":"searching-in-the-catalog","label":"Searching in the Catalog","html_id":"searching-in-the-catalog","implicit":true,"key":"rLneJmPTs8"},{"type":"paragraph","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"The module ","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"RPEZSMpNKr"},{"type":"inlineCode","value":"odc-stac","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"WDqzkaC9ce"},{"type":"text","value":" provides access to free, open source satelite data. To retrieve the data, we must define  several parameters that specify the location and time period for the satellite data. Additionally, we must specify the data collection we wish to access, as multiple collections are available. In this example, we will use multispectral imagery from the Sentinel-2 satellite.","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"q6YLNbImHY"}],"key":"yuWSjWkVaH"}],"key":"ySlsIJXXeF"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"dx = 0.0006  # 60m resolution\nepsg = 4326\n\n# Set Spatial extent\nlatmin, latmax = 47.86, 48.407\nlonmin, lonmax = 16.32, 16.9\nbounds = (lonmin, latmin, lonmax, latmax)\n\n\n# Set Temporal extent\nstart_date = datetime(year=2024, month=5, day=1)\nend_date = start_date + timedelta(days=10)\n\ntime_format = \"%Y-%m-%d\"\ndate_query = start_date.strftime(time_format) + \"/\" + end_date.strftime(time_format)\n\n# Search for Sentinel-2 data\nitems = (\n    pystac_client.Client.open(\"https://earth-search.aws.element84.com/v1\")\n    .search(\n        bbox=bounds,\n        collections=[\"sentinel-2-l2a\"],\n        datetime=date_query,\n        limit=100,\n    )\n    .item_collection()\n)\nprint(len(items), \"scenes found\")","key":"xG7ZinypVG"},{"type":"outputs","id":"UEC7igjXQBgB14QUFbT6I","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"stream","name":"stdout","text":"10 scenes found\n"},"key":"ipnONqeqso"}],"key":"MRqiHoU8n2"}],"key":"OVHpezQAFD"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"We will now focus on the area south-east of Vienna, where the Nationalpark ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"gPurW7pdyd"},{"type":"emphasis","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Donauauen","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"HrVXAu33Mh"}],"key":"dX4pJM3B51"},{"type":"text","value":" is situated. The time frame we are interested in is the beginning of May 2024.\nAfter passing these parameters to the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"muAb34W3lK"},{"type":"inlineCode","value":"stac-catalog","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"wt1Gof8aMC"},{"type":"text","value":" we have found ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"ZbDEnbxPtc"},{"type":"strong","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"10 scenes","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"mjISGesiXe"}],"key":"S7LMwwSDzD"},{"type":"text","value":" that we can use for our analysis.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"k8TgIoklRF"}],"key":"SK55Jr2Wl4"},{"type":"heading","depth":3,"position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"Loading the Data","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"dtYG6XXHxF"}],"identifier":"loading-the-data","label":"Loading the Data","html_id":"loading-the-data","implicit":true,"key":"dn4gMmauuV"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Now we will load the data directly into an ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"hggaC716lu"},{"type":"inlineCode","value":"xarray","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"b92fpnuAQv"},{"type":"text","value":" dataset, which we can use to perform computations on the data. ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"rPLX4RtpFn"},{"type":"inlineCode","value":"xarray","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"YSycLU0hcc"},{"type":"text","value":" is a powerful library for working with multi-dimensional arrays, making it well-suited for handling satellite data.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"MbdJmAz0sV"}],"key":"vJM7SNLysx"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Here’s how we can load the data using odc-stac and xarray:","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"YQoTJeMhyo"}],"key":"BTWGNMHzQi"}],"key":"NdwIdxwJAC"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# define a geobox for my region\ngeobox = GeoBox.from_bbox(bounds, crs=f\"epsg:{epsg}\", resolution=dx)\n\n# lazily combine items into a datacube\ndc = odc.stac.load(\n    items,\n    bands=[\"scl\", \"red\", \"green\", \"blue\", \"nir\"],\n    chunks={\"time\": 5, \"x\": 600, \"y\": 600},\n    geobox=geobox,\n    resampling=\"bilinear\",\n)\ndc","key":"VMZ95OFJlW"},{"type":"outputs","id":"4_JqyyK-fXckiPkGgtbhj","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"execute_result","execution_count":3,"metadata":{},"data":{"text/plain":{"content":"<xarray.Dataset> Size: 79MB\nDimensions:      (latitude: 913, longitude: 967, time: 10)\nCoordinates:\n  * latitude     (latitude) float64 7kB 48.41 48.41 48.41 ... 47.86 47.86 47.86\n  * longitude    (longitude) float64 8kB 16.32 16.32 16.32 ... 16.9 16.9 16.9\n  * time         (time) datetime64[ns] 80B 2024-05-01T09:57:21.858000 ... 202...\n    spatial_ref  int32 4B 4326\nData variables:\n    scl          (time, latitude, longitude) uint8 9MB dask.array<chunksize=(5, 600, 600), meta=np.ndarray>\n    red          (time, latitude, longitude) uint16 18MB dask.array<chunksize=(5, 600, 600), meta=np.ndarray>\n    green        (time, latitude, longitude) uint16 18MB dask.array<chunksize=(5, 600, 600), meta=np.ndarray>\n    blue         (time, latitude, longitude) uint16 18MB dask.array<chunksize=(5, 600, 600), meta=np.ndarray>\n    nir          (time, latitude, longitude) uint16 18MB dask.array<chunksize=(5, 600, 600), meta=np.ndarray>","content_type":"text/plain"},"text/html":{"content_type":"text/html","hash":"84f02f423fcb4778a6bb648f84a276e8","path":"/eo-datascience-cookbook/build/84f02f423fcb4778a6bb648f84a276e8.html"}}},"key":"VLaGvxlIdY"}],"key":"IdomGqGGwk"}],"key":"g6coLfNZV5"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Data Visualization","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"xa2LpmojcI"}],"identifier":"data-visualization","label":"Data Visualization","html_id":"data-visualization","implicit":true,"key":"Rut3T4NNP7"},{"type":"heading","depth":3,"position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"RGB Image","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"r1EVuNl5ls"}],"identifier":"rgb-image","label":"RGB Image","html_id":"rgb-image","implicit":true,"key":"BYyHrDdbY2"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"With the image data now in our possession, we can proceed with computations and visualizations.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"C6CfDYl0zy"}],"key":"whmnLCb0Ju"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"First, we define a mask to exclude cloud cover and areas with missing data. Subsequently, we create a composite median image, where each pixel value represents the median value across all the scenes we have identified. This approach helps to eliminate clouds and outliers present in some of the images, thereby providing a clearer and more representative visualization of the scene.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"YbR9TgiqYV"}],"key":"mt1pBPZF0Z"}],"key":"rIYkXa4Jqn"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# define a mask for valid pixels (non-cloud)\n\n\ndef is_valid_pixel(data):\n    # include only vegetated, not_vegitated, water, and snow\n    return ((data > 3) & (data < 7)) | (data == 11)\n\n\ndc[\"valid\"] = is_valid_pixel(dc.scl)\n\n# compute the masked median\nrgb_median = (\n    dc[[\"red\", \"green\", \"blue\"]]\n    .where(dc.valid)\n    .to_dataarray(dim=\"band\")\n    .median(dim=\"time\")\n    .astype(int)\n)\n\n# plot the median composite\ntitle_rgb = (\n    \"RGB - Median Composite\"\n    + f\"\\n{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}\"\n)\nrgb_median.plot.imshow(robust=True).axes.set_title(title_rgb)\nplt.show()","key":"cslJvEjHjs"},{"type":"outputs","id":"HCvX25urgYfhbWSAYspqG","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"stream","name":"stderr","text":"/home/runner/micromamba/envs/eo-datascience-cookbook/lib/python3.13/site-packages/rasterio/warp.py:387: NotGeoreferencedWarning: Dataset has no geotransform, gcps, or rpcs. The identity matrix will be returned.\n  dest = _reproject(\n"},"key":"TuYWoLhdaL"},{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"<Figure size 640x480 with 1 Axes>","content_type":"text/plain"},"image/png":{"content_type":"image/png","hash":"ab6355953f9d4fac62a75d0c3ffd1a82","path":"/eo-datascience-cookbook/build/ab6355953f9d4fac62a75d0c3ffd1a82.png"}}},"key":"Mxir2XEeAy"}],"key":"tcRKAzaUBN"}],"key":"p4shoDrbCW"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"False Color Image","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"Y4eThbA8OY"}],"identifier":"false-color-image","label":"False Color Image","html_id":"false-color-image","implicit":true,"key":"A2EqfYocUh"},{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"In addition to the regular RGB Image, we can swap any of the bands from the visible spectrum with any other bands. In this specific case the red band has been changed to the near infrared band. This allows us to see vegetated areas more clearly, since they now appear in a bright red color. This is due to the fact that plants absorb regular red light while reflecting near infrared light ","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"PMJjAciSev"},{"type":"citeGroup","kind":"parenthetical","children":[{"type":"cite","kind":"parenthetical","label":"nasa2020","identifier":"nasa2020","children":[{"type":"text","value":"NASA, 2020","key":"iLdQtdcfkE"}],"enumerator":"1","key":"pG6Gg7Q533"}],"key":"ELWTVAOge7"},{"type":"text","value":".","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"JSKDJcuvvp"}],"key":"jYl9mQVrgm"}],"key":"ka5fNIdX4r"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# compute a false color image\n# near infrared instead of red\nfc_median = (\n    dc[[\"nir\", \"green\", \"blue\"]]\n    .where(dc.valid)\n    .to_dataarray(dim=\"band\")\n    .transpose(..., \"band\")\n    .median(dim=\"time\")\n    .astype(int)\n)\n\ntitle_fc = (\n    \"False color - Median Composite\"\n    + f\"\\n{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}\"\n)\nfc_median.plot.imshow(robust=True).axes.set_title(title_fc)\nplt.show()","key":"HXazfCRY3a"},{"type":"outputs","id":"ZGVS_T0OS7JwRIy6n2SoE","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"<Figure size 640x480 with 1 Axes>","content_type":"text/plain"},"image/png":{"content_type":"image/png","hash":"da6a8f5ac76fd1806e03b5cf70b7e830","path":"/eo-datascience-cookbook/build/da6a8f5ac76fd1806e03b5cf70b7e830.png"}}},"key":"fskzElPKjZ"}],"key":"xzTwUSH0TT"}],"key":"eolZuoWkK9"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"NDVI Image","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"k5tKdLWXX5"}],"identifier":"ndvi-image","label":"NDVI Image","html_id":"ndvi-image","implicit":true,"key":"MrxGv1E7Pp"},{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"To get an first impression of the data, we can calculate the NDVI (Normalized Difference Vegetation Index) and plot it. The NDVI is calculated by useing the following formula. ","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"WYk6gwIfxG"},{"type":"citeGroup","kind":"parenthetical","children":[{"type":"cite","kind":"parenthetical","label":"rouse1974monitoring","identifier":"rouse1974monitoring","children":[{"type":"text","value":"Rouse ","key":"CznrktTCFq"},{"type":"emphasis","children":[{"type":"text","value":"et al.","key":"GdjvDkyENZ"}],"key":"LWvBfJD6lb"},{"type":"text","value":", 1974","key":"QuIvQs4voT"}],"enumerator":"2","key":"zzwCcFWyCR"}],"key":"o0Lc0whXmu"}],"key":"UPGUsu4daZ"},{"type":"math","value":"NDVI = \\frac{NIR - Red}{NIR + Red}","position":{"start":{"line":4,"column":1},"end":{"line":6,"column":1}},"html":"<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>N</mi><mi>D</mi><mi>V</mi><mi>I</mi><mo>=</mo><mfrac><mrow><mi>N</mi><mi>I</mi><mi>R</mi><mo>−</mo><mi>R</mi><mi>e</mi><mi>d</mi></mrow><mrow><mi>N</mi><mi>I</mi><mi>R</mi><mo>+</mo><mi>R</mi><mi>e</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">NDVI = \\frac{NIR - Red}{NIR + Red}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.1408em;vertical-align:-0.7693em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3714em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span>","enumerator":"1","key":"oedcSwACtI"},{"type":"paragraph","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"children":[{"type":"text","value":"This gives us a good overview of the vegetation in the area. The values can range from -1 to 1 where the following meanings are associated with these values:","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"mgtCQr40i6"}],"key":"MDIHDWe2q3"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":10,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"-1 to 0 indicate dead plants or inanimate objects","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"YEfBQeCBiO"}],"key":"QXgFYGc631"}],"key":"YtFa649AYZ"},{"type":"listItem","spread":true,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"0 to 0.33 are unhealthy plants","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"wKhnvAJgNi"}],"key":"DeqnIHZqjd"}],"key":"B7MfQzHUgn"},{"type":"listItem","spread":true,"position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"0.33 to 0.66 are moderatly healthy plants","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"pUJt3WBiPI"}],"key":"XLe4NaUuSK"}],"key":"MWuiUOeJsG"},{"type":"listItem","spread":true,"position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"0.66 to 1 are very healthy plants","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"X3ZfqB0a4I"}],"key":"lSe4XfoSsy"}],"key":"s7xzeyEiy8"}],"key":"DIyIvvUs3W"}],"key":"PRGBGsus4u"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Normalized Difference Vegetation Index (NDVI)\n\n\ndef normalized_difference(a, b):\n    return (a - b * 1.0) / (a + b)\n\n\nndvi = normalized_difference(dc.nir, dc.red)\nndvi.median(dim=\"time\").plot.imshow(cmap=\"cmc.cork\", vmin=-1, vmax=1).axes.set_title(\n    \"NDVI\"\n)\nplt.show()","key":"HhezpPzwnP"},{"type":"outputs","id":"JCAlsMxuhFGH9Xn0-_iqn","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"<Figure size 640x480 with 2 Axes>","content_type":"text/plain"},"image/png":{"content_type":"image/png","hash":"13cb675f3f937f79eafb571b4a3d1c0b","path":"/eo-datascience-cookbook/build/13cb675f3f937f79eafb571b4a3d1c0b.png"}}},"key":"echEdfkD8f"}],"key":"Ri04weBU4a"}],"key":"QzDxEjPG3V"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Classification","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"PYgA1QbfrK"}],"identifier":"classification","label":"Classification","html_id":"classification","implicit":true,"key":"uC1rQs0lTH"},{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"In this chapter, we will classify the satellite data to identify forested areas within the scene. By using supervised machine learning techniques, we can train classifiers to distinguish between forested and non-forested regions based on the training data we provide. We will explore two different classifiers and compare their performance in accurately identifying forest areas.","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"lgT2Ie8Htk"}],"key":"KG5nCxCzQb"},{"type":"heading","depth":3,"position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"Regions of Interest","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"FN4GHxXThA"}],"identifier":"regions-of-interest","label":"Regions of Interest","html_id":"regions-of-interest","implicit":true,"key":"HZqhEQl3pf"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Since this is a supervised classification, we need to have some training data. Therefore we need to define areas or regions, which we are certain represent the feature which we are classifiying. In this case we are interested in forested areas and regions that are definitly not forested. These regions will be used to train our classifiers.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"Oh934zxiHy"}],"key":"UqWzBQAp0B"}],"key":"hPt9soF4nv"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Define Polygons\nforest_areas = {\n    0: [\n        Polygon(\n            [\n                (16.482772, 47.901753),\n                (16.465133, 47.870124),\n                (16.510142, 47.874382),\n                (16.482772, 47.901753),\n            ]\n        )\n    ],\n    1: [\n        Polygon(\n            [\n                (16.594079, 47.938855),\n                (16.581914, 47.894454),\n                (16.620233, 47.910268),\n                (16.594079, 47.938855),\n            ]\n        )\n    ],\n    2: [\n        Polygon(\n            [\n                (16.67984, 47.978998),\n                (16.637263, 47.971091),\n                (16.660376, 47.929123),\n                (16.67984, 47.978998),\n            ]\n        )\n    ],\n    3: [\n        Polygon(\n            [\n                (16.756477, 48.000286),\n                (16.723024, 47.983256),\n                (16.739446, 47.972916),\n                (16.756477, 48.000286),\n            ]\n        )\n    ],\n    4: [\n        Polygon(\n            [\n                (16.80696, 48.135923),\n                (16.780806, 48.125583),\n                (16.798445, 48.115243),\n                (16.80696, 48.135923),\n            ]\n        )\n    ],\n    5: [\n        Polygon(\n            [\n                (16.684097, 48.144438),\n                (16.664634, 48.124366),\n                (16.690788, 48.118892),\n                (16.684097, 48.144438),\n            ]\n        )\n    ],\n    6: [\n        Polygon(\n            [\n                (16.550894, 48.169984),\n                (16.530822, 48.165118),\n                (16.558801, 48.137139),\n                (16.550894, 48.169984),\n            ]\n        )\n    ],\n    7: [\n        Polygon(\n            [\n                (16.588604, 48.402329),\n                (16.556976, 48.401112),\n                (16.580697, 48.382865),\n                (16.588604, 48.402329),\n            ]\n        )\n    ],\n}\n\nnonforest_areas = {\n    0: [\n        Polygon(\n            [\n                (16.674974, 48.269126),\n                (16.623882, 48.236281),\n                (16.682272, 48.213168),\n                (16.674974, 48.269126),\n            ]\n        )\n    ],\n    1: [\n        Polygon(\n            [\n                (16.375723, 48.228374),\n                (16.357476, 48.188839),\n                (16.399444, 48.185798),\n                (16.375723, 48.228374),\n            ]\n        )\n    ],\n    2: [\n        Polygon(\n            [\n                (16.457834, 48.26426),\n                (16.418907, 48.267301),\n                (16.440804, 48.23324),\n                (16.457834, 48.26426),\n            ]\n        )\n    ],\n    3: [\n        Polygon(\n            [\n                (16.519266, 48.101861),\n                (16.470607, 48.100645),\n                (16.500411, 48.07145),\n                (16.519266, 48.101861),\n            ]\n        )\n    ],\n    4: [\n        Polygon(\n            [\n                (16.453577, 48.051986),\n                (16.412217, 48.067192),\n                (16.425598, 48.012451),\n                (16.453577, 48.051986),\n            ]\n        )\n    ],\n}","key":"IvjlZ16ONT"},{"type":"outputs","id":"x2UXxXlAd0oVVZ_oW3-na","children":[],"key":"cfipRZCiK3"}],"key":"MotmpeEsER"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Geoppandas Dataframe from Polygons\nforest_df = gpd.GeoDataFrame(\n    {\"geometry\": [poly[0] for poly in forest_areas.values()]}, crs=\"EPSG:4326\"\n)\nnonforest_df = gpd.GeoDataFrame(\n    {\"geometry\": [poly[0] for poly in nonforest_areas.values()]},\n    crs=\"EPSG:4326\",\n)\n\n\n# Plotting Regions of Interest\nfig, ax = plt.subplots()\nrgb_median.plot.imshow(ax=ax, robust=True)\nforest_df.plot(ax=ax, ec=\"C0\", fc=\"none\")\nnonforest_df.plot(ax=ax, ec=\"C1\", fc=\"none\")\nax.set_title(\"Regions of Interest\")\nax.set_aspect(\"equal\")\nplt.show()","key":"bALF7RonPt"},{"type":"outputs","id":"izXKaxtXagxlVaKYC3n8g","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"<Figure size 640x480 with 1 Axes>","content_type":"text/plain"},"image/png":{"content_type":"image/png","hash":"a77ab3d265de5c070711e3b39705afa9","path":"/eo-datascience-cookbook/build/a77ab3d265de5c070711e3b39705afa9.png"}}},"key":"SBWXSTSjRp"}],"key":"Ngks5Vwbq2"}],"key":"ZanqbTpBy4"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Data Preparation","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"onmSYTRpQ2"}],"identifier":"data-preparation","label":"Data Preparation","html_id":"data-preparation","implicit":true,"key":"U9Re1YDkJj"},{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"In addition to the Regions of Interest we will extract the specific bands from the loaded dataset that we intend to use for the classification, which are the ","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"dJatDw6xBY"},{"type":"inlineCode","value":"red, green, blue","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"WaZdoMlXS8"},{"type":"text","value":" and ","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"z5KRfLCB7F"},{"type":"inlineCode","value":"near-infrared","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"n52OQbOcpl"},{"type":"text","value":" bands, although other bands can also be utilized. Using these bands, we will create both a training and a testing dataset. The training dataset will be used to train the classifier, while the testing dataset will be employed to evaluate its performance.","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"vyECd1g3tU"}],"key":"zBHl2ojgMW"}],"key":"EpWSRRJVo6"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Classifiying dataset (only necessary bands)\nbands = [\"red\", \"green\", \"blue\", \"nir\"]\nds_class = dc[bands].where(dc.valid).median(dim=\"time\")\nds_class = ds_class.fillna(0)\n\n\ndef clip_array(ds: xr.Dataset, polygons):\n    clipped = ds.rio.clip(polygons, invert=False, all_touched=False, drop=True)\n    clipped_nan = clipped.where(clipped == ds)\n    return clipped_nan\n\n\n# Dictionaries with Dataarrays, each clipped by a Polygon\ndata_dict_feat = {\n    idx: clip_array(ds_class, polygon) for idx, polygon in forest_areas.items()\n}\ndata_dict_nonfeat = {\n    idx: clip_array(ds_class, polygon) for idx, polygon in nonforest_areas.items()\n}","key":"qNrEgdWZyp"},{"type":"outputs","id":"obESR3W7l6r_XaZU9n0IU","children":[],"key":"RjXA2rtBLa"}],"key":"mP0AjE6Wjy"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Reshape the polygon dataarrays to get a tuple (one value per band) of pixel values\nfeat_data = [\n    xarray.to_array().values.reshape(len(bands), -1).T\n    for xarray in data_dict_feat.values()\n]  # replaced median_data_dict_feat with data_dict_feat\nnonfeat_data = [\n    xarray.to_array().values.reshape(len(bands), -1).T\n    for xarray in data_dict_nonfeat.values()\n]  # replaced median_data_dict_feat with data_dict_feat\n\n# The rows of the different polygons are concatenated to a single array for further processing\nfeat_values = np.concatenate(feat_data)\nnonfeat_values = np.concatenate(nonfeat_data)\n\n# Drop Nan Values\nX_feat_data = feat_values[~np.isnan(feat_values).any(axis=1)]\nX_nonfeat_data = nonfeat_values[~np.isnan(nonfeat_values).any(axis=1)]","key":"aBVPyDTuhP"},{"type":"outputs","id":"GoOyBgYGFgJetmtoUSG-k","children":[],"key":"bC1V8IguGD"}],"key":"L9TP2kFlC6"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Creating Output Vector (1 for pixel is features; 0 for pixel is not feature)\ny_feat_data = np.ones(X_feat_data.shape[0])\ny_nonfeat_data = np.zeros(X_nonfeat_data.shape[0])\n\n# Concatenate all Classes for training\nX = np.concatenate([X_feat_data, X_nonfeat_data])\ny = np.concatenate([y_feat_data, y_nonfeat_data])\n\n# Split into Training and Testing Data.\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.5, random_state=42\n)","key":"dyCebjEWQo"},{"type":"outputs","id":"GcjcdtbV3HYLt9xgxCP8V","children":[],"key":"kHJ9V3Mgwl"}],"key":"Rp0CUFSkeN"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Now that we have prepared the training and testing data, we will create an image array of the actual scene that we intend to classify. This array will serve as the input for our classification algorithms, allowing us to apply the trained classifiers to the entire scene and identify the forested and non-forested areas accurately.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"DWhkz7k40P"}],"key":"PwLP7fNjIN"}],"key":"FEwHo0zttI"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"image_data = (\n    ds_class[bands].to_array(dim=\"band\").transpose(\"latitude\", \"longitude\", \"band\")\n)\n\n# Reshape the image data\nnum_of_pixels = ds_class.sizes[\"longitude\"] * ds_class.sizes[\"latitude\"]\nnum_of_bands = len(bands)\nX_image_data = image_data.values.reshape(num_of_pixels, num_of_bands)","key":"qwvkh7pq7O"},{"type":"outputs","id":"_KE8yh-hkLwB2ssTZIrku","children":[],"key":"rPU9nT6qz8"}],"key":"YFw2lzz01a"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Classifiying with Naive Bayes","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"IXgEJOyAOK"}],"identifier":"classifiying-with-naive-bayes","label":"Classifiying with Naive Bayes","html_id":"classifiying-with-naive-bayes","implicit":true,"key":"lYpcc0lMyg"},{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"Now that we have prepared all the needed data, we can begin the actual classification process.","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"TfsermZACe"}],"key":"Lx3iQQKgQi"},{"type":"paragraph","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"We will start with a ","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"COz8GViAZF"},{"type":"emphasis","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"Naive Bayes","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"vOTFFrX3Jt"}],"key":"nSJREKIfib"},{"type":"text","value":" classifier. First, we will train the classifier using our training dataset. Once trained, we will apply the classifier to the actual image to identify the forested and non-forested areas.","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"I9t15Ok3Ki"}],"key":"MittiF0XOX"}],"key":"qkV6ik0jHh"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Naive Bayes initialization and training\nnb = GaussianNB()\nnb_test = nb.fit(X_train, y_train)\nnb_predict = nb.predict(X_test)\n\n# Prediction on image\nnb_predict_img = nb.predict(X_image_data)\nnb_predict_img = nb_predict_img.reshape(\n    ds_class.sizes[\"latitude\"], ds_class.sizes[\"longitude\"]\n)\n\n# Adding the Naive Bayes Prediction to the dataset\nds_class[\"NB-forest\"] = xr.DataArray(\n    nb_predict_img,\n    dims=[\"latitude\", \"longitude\"],\n    coords={\n        \"longitude\": ds_class[\"longitude\"],\n        \"latitude\": ds_class[\"latitude\"],\n    },\n)","key":"l1cAaPaPOZ"},{"type":"outputs","id":"QMoqRcwZQIO5MGgIKdwly","children":[],"key":"Wh7nF6ush4"}],"key":"kirizDphs6"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"To evaluate the effectiveness of the classification, we will plot the image predicted by the classifier. Additionally, we will examine the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"rfdb9ATjZU"},{"type":"inlineCode","value":"Classification Report","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"dyAmNJkLRM"},{"type":"text","value":" and the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"Q5ZXyW7qql"},{"type":"inlineCode","value":"Confusion Matrix","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"bMXGIcSeuw"},{"type":"text","value":" to gain further insights into the classifier’s performance.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"gMqEwIUccx"}],"key":"EJTnqnsgGQ"}],"key":"rm1EhWNU5E"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Plot Naive Bayes\nalpha = 1\ncmap_green = colors.ListedColormap([(1, 1, 1, alpha), \"green\"])\n\nplot = ds_class[\"NB-forest\"].plot.imshow(\n    cmap=cmap_green, cbar_kwargs={\"ticks\": [0.25, 0.75]}\n)\ncbar = plot.colorbar\ncbar.set_ticklabels([\"non-forest\", \"forest\"])\nplot.axes.set_title(\"Naive Bayes Classification\")\nplt.show()\n\n# Print the Classification report\nprint(\"NAIVE BAYES: \\n \" + classification_report(y_test, nb_predict))\n\n# Print the confusion matrix\ncon_mat_nb = pd.DataFrame(\n    confusion_matrix(y_test, nb_predict),\n    index=[\"Actual Negative\", \"Actual Positive\"],\n    columns=[\"Predicted Negative\", \"Predicted Positive\"],\n)\ndisplay(con_mat_nb)","key":"Z5mqIx0lDC"},{"type":"outputs","id":"23bJFwFbRt9UB3RPuu63R","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"<Figure size 640x480 with 2 Axes>","content_type":"text/plain"},"image/png":{"content_type":"image/png","hash":"ffb395d59a05985a2643941fffbb0475","path":"/eo-datascience-cookbook/build/ffb395d59a05985a2643941fffbb0475.png"}}},"key":"WrDv9qkQte"},{"type":"output","children":[],"jupyter_data":{"output_type":"stream","name":"stdout","text":"NAIVE BAYES: \n               precision    recall  f1-score   support\n\n         0.0       0.95      0.82      0.88      6626\n         1.0       0.81      0.95      0.87      5485\n\n    accuracy                           0.88     12111\n   macro avg       0.88      0.88      0.88     12111\nweighted avg       0.89      0.88      0.88     12111\n\n"},"key":"RoJ9ztC2bS"},{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"                 Predicted Negative  Predicted Positive\nActual Negative                5415                1211\nActual Positive                 290                5195","content_type":"text/plain"},"text/html":{"content":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Predicted Negative</th>\n      <th>Predicted Positive</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Actual Negative</th>\n      <td>5415</td>\n      <td>1211</td>\n    </tr>\n    <tr>\n      <th>Actual Positive</th>\n      <td>290</td>\n      <td>5195</td>\n    </tr>\n  </tbody>\n</table>\n</div>","content_type":"text/html"}}},"key":"Azh1nxFAhJ"}],"key":"h1jRpmvKDr"}],"key":"R75hEKBS2N"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":3,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Classifiying with Random Forest","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"DRoMl4eOAL"}],"identifier":"classifiying-with-random-forest","label":"Classifiying with Random Forest","html_id":"classifiying-with-random-forest","implicit":true,"key":"hzHa5RS3vc"},{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"To ensure our results are robust, we will explore an additional classifier. In this section, we will use the Random Forest classifier. The procedure for using this classifier is the same as before: we will train the classifier using our training dataset and then apply it to the actual image to classify the scene.","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"xwyVbwHEcK"}],"key":"r3irM028cZ"}],"key":"FIgGr4HhTR"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Random Forest initialization and training\nrf = RandomForestClassifier(n_estimators=100)\nrf_test = rf.fit(X_train, y_train)\nrf_predict = rf.predict(X_test)\n\n# Prediction on image\nrf_predict_img = rf.predict(X_image_data)\nrf_predict_img = rf_predict_img.reshape(\n    ds_class.sizes[\"latitude\"], ds_class.sizes[\"longitude\"]\n)\n\n# Adding the Random Forest Prediction to the dataset\nds_class[\"RF-forest\"] = xr.DataArray(\n    rf_predict_img,\n    dims=[\"latitude\", \"longitude\"],\n    coords={\n        \"longitude\": ds_class[\"longitude\"],\n        \"latitude\": ds_class[\"latitude\"],\n    },\n)\n\nplot = ds_class[\"RF-forest\"].plot.imshow(\n    cmap=cmap_green, cbar_kwargs={\"ticks\": [0.25, 0.75]}\n)\ncbar = plot.colorbar\ncbar.set_ticklabels([\"non-forest\", \"forest\"])\nplot.axes.set_title(\"Random Forest Classification\")\nplt.show()\n\n# Print the Classification report\nprint(\"RANDOM FOREST: \\n \" + classification_report(y_test, rf_predict))\n\n# Print the confusion matrix\ncon_mat_rf = pd.DataFrame(\n    confusion_matrix(y_test, rf_predict),\n    index=[\"Actual Negative\", \"Actual Positive\"],\n    columns=[\"Predicted Negative\", \"Predicted Positive\"],\n)\ndisplay(con_mat_rf)","key":"Ter4WCrOUL"},{"type":"outputs","id":"awVxIOPglUcOkmo9LFw6p","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"<Figure size 640x480 with 2 Axes>","content_type":"text/plain"},"image/png":{"content_type":"image/png","hash":"a0102c56f9fa8721fe9b11e5f011072f","path":"/eo-datascience-cookbook/build/a0102c56f9fa8721fe9b11e5f011072f.png"}}},"key":"NiIt6HpZZc"},{"type":"output","children":[],"jupyter_data":{"output_type":"stream","name":"stdout","text":"RANDOM FOREST: \n               precision    recall  f1-score   support\n\n         0.0       0.96      0.95      0.95      6626\n         1.0       0.94      0.95      0.94      5485\n\n    accuracy                           0.95     12111\n   macro avg       0.95      0.95      0.95     12111\nweighted avg       0.95      0.95      0.95     12111\n\n"},"key":"O6Fzcyne0q"},{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"                 Predicted Negative  Predicted Positive\nActual Negative                6293                 333\nActual Positive                 276                5209","content_type":"text/plain"},"text/html":{"content":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Predicted Negative</th>\n      <th>Predicted Positive</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Actual Negative</th>\n      <td>6293</td>\n      <td>333</td>\n    </tr>\n    <tr>\n      <th>Actual Positive</th>\n      <td>276</td>\n      <td>5209</td>\n    </tr>\n  </tbody>\n</table>\n</div>","content_type":"text/html"}}},"key":"PSPpjYsCE0"}],"key":"SqAoplMSIE"}],"key":"ROlPLDzzL5"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"We can already see from the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"X0i1gJOUNm"},{"type":"inlineCode","value":"classification reports","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"pqtoeiYNju"},{"type":"text","value":" and the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"NNGf9z8Z3B"},{"type":"inlineCode","value":"confusion matrices","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"zkeEf8T8Qx"},{"type":"text","value":" that the Random Forest classifier has outperformed the Naive Bayes classifier. This is particularly evident from the lower values in the secondary diagonal, indicating minimal False Positives and False Negatives. It appears that the Naive Bayes classifier is more sensitive to False Positives, resulting in a higher rate of incorrect classifications.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"FJZZB79SWN"}],"key":"HcBDpsS7dl"},{"type":"heading","depth":3,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Comparison of the Classificators","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"eoU1z31axe"}],"identifier":"comparison-of-the-classificators","label":"Comparison of the Classificators","html_id":"comparison-of-the-classificators","implicit":true,"key":"XFe5sd79E8"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"To gain a more in-depth understanding of the classifiers’ performance, we will compare their results. Specifically, we will identify the areas where both classifiers agree and the areas where they disagree. This comparison will provide valuable insights into the strengths and weaknesses of each classifier, allowing us to better assess their effectiveness in identifying forested and non-forested regions.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"KKx1BuQPpb"}],"key":"boYH7yTp60"}],"key":"ZiBDJ7OGBL"},{"type":"block","kind":"notebook-code","data":{"code-fold":true},"children":[{"type":"code","lang":"python","executable":true,"value":"cmap_trio = colors.ListedColormap([\"whitesmoke\", \"indianred\", \"goldenrod\", \"darkgreen\"])\n\n\ndouble_clf = ds_class[\"NB-forest\"] + 2 * ds_class[\"RF-forest\"]\n\nfig, ax = plt.subplots()\ncax = ax.imshow(double_clf, cmap=cmap_trio, interpolation=\"none\")\n\n# Add a colorbar with custom tick labels\ncbar = fig.colorbar(cax, ticks=[1 * 0.375, 3 * 0.375, 5 * 0.375, 7 * 0.375])\ncbar.ax.set_yticklabels([\"None\", \"Naive Bayes\", \"Random Forest\", \"Both\"])\nax.set_title(\"Classification Comparisson\")\nax.set_axis_off()\nplt.show()","key":"Lktf0GWz3h"},{"type":"outputs","id":"89r92WzMlDQPEx30SmWgY","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"<Figure size 640x480 with 2 Axes>","content_type":"text/plain"},"image/png":{"content_type":"image/png","hash":"cf644d3bf33b80a850b18c6f574dc07e","path":"/eo-datascience-cookbook/build/cf644d3bf33b80a850b18c6f574dc07e.png"}}},"key":"ugIrnrMyvE"}],"key":"z6qCym43iA"}],"key":"RroRNfnLJD"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"The areas where both classifiers agree include the larger forested regions, such as the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"RVnRACJzFD"},{"type":"emphasis","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Nationalpark Donau-Auen","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"h4nA8B3G3Q"}],"key":"Ctd3kH7Ybd"},{"type":"text","value":" and the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"iuUc2A34wE"},{"type":"emphasis","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Leithagebirge","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"ApQRpPKCdX"}],"key":"v4IHqCIU1D"},{"type":"text","value":". Additionally, both classifiers accurately identified the urban areas of Vienna and correctly excluded them from being classified as forested.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"GyTblX8njl"}],"key":"q1xwiqQarc"}],"key":"cwwGwZCGH6"},{"type":"block","kind":"notebook-code","data":{"code-fold":true},"children":[{"type":"code","lang":"python","executable":true,"value":"# Plot only one class, either None (0), Naive Bayes (1), Random Forest (2), or Both (3)\nfig, axs = plt.subplots(2, 2, figsize=(8, 8))\nax = axs.ravel()\n\nfor i in range(4):\n    ax[i].imshow(double_clf == i, cmap=\"cmc.oleron_r\", interpolation=\"none\")\n    category = [\n        \"by None\",\n        \"only by Naive Bayes\",\n        \"only by Random Forest\",\n        \"by Both\",\n    ][i]\n    title = \"Areas classified \" + category\n    ax[i].set_title(title)\n    ax[i].set_axis_off()\n\nplt.tight_layout()","key":"qxKfZjolhT"},{"type":"outputs","id":"7pI6mh0AAurKCuF5qWW5h","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"<Figure size 800x800 with 4 Axes>","content_type":"text/plain"},"image/png":{"content_type":"image/png","hash":"a8d5c9d0957b7a8c5b3d5d02b9b9c009","path":"/eo-datascience-cookbook/build/a8d5c9d0957b7a8c5b3d5d02b9b9c009.png"}}},"key":"xIvaUEtmAO"}],"key":"YG0QLFKJPE"}],"key":"Ax4U2NV2N7"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"When plotting the classified areas individually, we observe that the Random Forest classifier mistakenly identified the Danube River as a forested area. Conversely, the Naive Bayes classifier erroneously classified a significant amount of cropland as forest.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"z1LspIh84C"}],"key":"ZjxhleTpqP"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Finally, by analyzing the proportion of forested areas within the scene, we find that approximately 18% of the area is classified as forest, while around 66% is classified as non-forest. The remaining areas, which include water bodies and cropland, fall into less clearly defined categories.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"hGO5qRFPT1"}],"key":"HAHtG4WIbo"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"The accompanying bar chart illustrates the distribution of these classifications, highlighting the percentage of forested areas, non-forested areas, and regions classified by only one of the two classifiers. This visual representation helps to quantify the areas of agreement and disagreement between the classifiers, providing a clearer picture of their performance.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"LfVuIpMacD"}],"key":"rZZkSQrxFR"}],"key":"EbumGxTtGS"},{"type":"block","kind":"notebook-code","data":{"code-fold":true},"children":[{"type":"code","lang":"python","executable":true,"value":"counts = {}\nfor num in range(0, 4):\n    num_2_class = {0: \"None\", 1: \"Naive Bayes\", 2: \"Random Forest\", 3: \"Both\"}\n    counts[num_2_class[num]] = int((double_clf == num).sum().values)\n\nclass_counts_df = pd.DataFrame(list(counts.items()), columns=[\"Class\", \"Count\"])\nclass_counts_df[\"Percentage\"] = (\n    class_counts_df[\"Count\"] / class_counts_df[\"Count\"].sum()\n) * 100\nax = class_counts_df.plot.bar(\n    x=\"Class\",\n    y=\"Percentage\",\n    rot=0,\n    color=\"darkgreen\",\n    ylim=(0, 100),\n    title=\"Classified Areas per Classificator (%)\",\n)\n\n# Annotate the bars with the percentage values\nfor p in ax.patches:\n    ax.annotate(\n        f\"{p.get_height():.1f}%\",\n        (p.get_x() + p.get_width() / 2.0, p.get_height()),\n        ha=\"center\",\n        va=\"center\",\n        xytext=(0, 9),\n        textcoords=\"offset points\",\n    )","key":"h9kZKov5nI"},{"type":"outputs","id":"GFlXqa52pgkYZ-Ubg-Awf","children":[{"type":"output","children":[],"jupyter_data":{"output_type":"display_data","metadata":{},"data":{"text/plain":{"content":"<Figure size 640x480 with 1 Axes>","content_type":"text/plain"},"image/png":{"content_type":"image/png","hash":"9fe1f00b3efcf81da9db93d4a17f69b6","path":"/eo-datascience-cookbook/build/9fe1f00b3efcf81da9db93d4a17f69b6.png"}}},"key":"W5vKjYl5uH"}],"key":"SMbpq88D7I"}],"key":"dGikqxfjuR"},{"type":"block","kind":"notebook-content","children":[{"type":"heading","depth":2,"position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Conclusion","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"uMdYwg5vLA"}],"identifier":"conclusion","label":"Conclusion","html_id":"conclusion","implicit":true,"key":"PzqCnqitWZ"},{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"In this chapter, we utilized machine learning to classify satellite imagery into forested and non-forested areas, comparing Naive Bayes and Random Forest classifiers. The Random Forest classifier generally outperformed Naive Bayes, with fewer errors in classification, although it misclassified the Danube River as forested, while Naive Bayes incorrectly identified cropland as forest. The analysis, supported by the bar chart, revealed that about 18% of the scene was classified as forest, 66% as non-forest, and the remainder included ambiguous categories. This comparison highlights the strengths and limitations of each classifier, underscoring the need for careful selection and evaluation of classification methods.","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"ku7pEriD0P"}],"key":"nAVscfNW8b"}],"key":"fbggC7i8UY"}],"key":"w2dbPFCxaA"},"references":{"cite":{"order":["nasa2020","rouse1974monitoring"],"data":{"nasa2020":{"label":"nasa2020","enumerator":"1","html":"NASA. (2020). <i>Earth Observatory</i>. <a target=\"_blank\" rel=\"noreferrer\" href=\"https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php\">https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php</a>","url":"https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php"},"rouse1974monitoring":{"label":"rouse1974monitoring","enumerator":"2","html":"Rouse, J. W., Haas, R. H., Schell, J. A., Deering, D. W., & others. (1974). Monitoring vegetation systems in the Great Plains with ERTS. <i>NASA Spec. Publ</i>, <i>351</i>(1), 309."}}}},"footer":{"navigation":{"prev":{"title":"Templates","url":"/notebooks/templates/prereqs-templates","group":"Templates"},"next":{"title":"Tutorials","url":"/notebooks/tutorials/prereqs-tutorials","group":"Tutorials"}}},"domain":"http://localhost:3000"}